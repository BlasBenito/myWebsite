tsl = tsl_subset(
tsl = tsl,
names = c("Los_Angeles", "Kings"),
time = c("2021-09-01", "2022-01-31")
),
guide = FALSE
)
df_time <- distantia::tsl_time(
tsl = tsl
)
df_time |>
dplyr::select(name, class, units, length, resolution, begin, end) |>
reactable::reactable(
pagination = TRUE,
searchable = TRUE,
sortable = TRUE,
showSortable = TRUE,
filterable = TRUE,
resizable = TRUE,
defaultPageSize = 10,
showPageSizeOptions = TRUE,
striped = TRUE,
compact = TRUE,
wrap = FALSE,
fullWidth = FALSE
)
df_stats <- distantia::tsl_stats(
tsl = tsl,
lags = 1:6 #weeks
)
df_stats |>
dplyr::select(name, min, q1, median, q3, max, sd, range, iq_range, skewness, kurtosis) |>
dplyr::mutate(dplyr::across(dplyr::where(is.numeric), ~ round(.x, 2))) |>
reactable::reactable(
pagination = TRUE,
searchable = TRUE,
sortable = TRUE,
showSortable = TRUE,
filterable = TRUE,
resizable = TRUE,
defaultPageSize = 10,
showPageSizeOptions = TRUE,
striped = TRUE,
compact = TRUE,
wrap = FALSE,
fullWidth = FALSE
)
df_stats |>
select(name, dplyr::contains("lag")) |>
dplyr::mutate(dplyr::across(dplyr::where(is.numeric), ~ round(.x, 2))) |>
dplyr::rename_with(~ gsub("ac_", "", .)) |>
dplyr::rename_with(~ gsub("_", "", .)) |>
reactable::reactable(
pagination = TRUE,
searchable = TRUE,
sortable = TRUE,
showSortable = TRUE,
filterable = TRUE,
resizable = TRUE,
defaultPageSize = 10,
showPageSizeOptions = TRUE,
striped = TRUE,
compact = TRUE,
wrap = FALSE,
fullWidth = TRUE
)
sf_stats <- dplyr::inner_join(
x = covid_counties[, "name"],
y = df_stats,
by = "name"
)
max_prevalence <- mapview(
sf_stats,
zcol = "max",
label = "name",
col.regions = distantia::color_continuous()
)
htmlwidgets::saveWidget(
max_prevalence@map,
file = "max_prevalence.html",
selfcontained = TRUE
)
rm(max_prevalence)
tsl_smol <- distantia::tsl_subset(
tsl = tsl,
names = c("San_Francisco", "Napa", "Solano"),
time = c("2021-01-01", "2023-01-01")
)
distantia::tsl_plot(
tsl = tsl_smol,
guide = FALSE,
text_cex = 1.3
)
tsl_smol |>
distantia::distantia_ls() |>
dplyr::mutate(
psi = round(psi, 3)
) |>
reactable::reactable(
resizable = TRUE,
striped = TRUE,
compact = TRUE,
wrap = FALSE,
fullWidth = FALSE
)
tsl_smol |>
distantia::distantia_dtw() |>
dplyr::mutate(
psi = round(psi, 3)
) |>
reactable::reactable(
resizable = TRUE,
striped = TRUE,
compact = TRUE,
wrap = FALSE,
fullWidth = FALSE
)
xy_dtw <- dtw::dtw(
x = tsl_smol$Solano$prevalence,
y = tsl_smol$San_Francisco$prevalence,
keep = TRUE
)
dtw::dtwPlotTwoWay(xy_dtw, offset = 0.5)
rm(xy_dtw)
df_psi_ls <- distantia::distantia_ls(
tsl = tsl,
distance = "euclidean"
)
str(df_psi_ls)
df_psi_dtw <- distantia::distantia_dtw(
tsl = tsl
)
str(df_psi_dtw)
df_table <- df_psi_dtw |>
dplyr::select(x, y, psi) |>
dplyr::inner_join(
y = dplyr::select(df_psi_ls, x, y, psi),
by = c("x", "y")
) |>
dplyr::transmute(
x, y,
`psi_dtw` = round(psi.x, 3),
psi_ls = round(psi.y, 3)
)
reactable::reactable(
df_table,
pagination = TRUE,
searchable = TRUE,
sortable = TRUE,
showSortable = TRUE,
filterable = TRUE,
resizable = TRUE,
defaultPageSize = 10,
showPageSizeOptions = TRUE,
striped = TRUE,
compact = TRUE,
wrap = FALSE,
fullWidth = FALSE
)
rm(df_table)
df_psi <- df_psi_dtw
df_psi_stats <- distantia::distantia_stats(
df = df_psi
)
reactable::reactable(
df_psi_stats |>
mutate_if(is.numeric, round, 3),
pagination = FALSE,
sortable = TRUE,
showSortable = TRUE,
filterable = TRUE,
resizable = TRUE,
defaultPageSize = nrow(df_psi_stats),
showPageSizeOptions = TRUE,
striped = TRUE,
compact = TRUE,
wrap = FALSE,
fullWidth = TRUE
)
distantia::distantia_boxplot(
df = df_psi,
text_cex = 1.4
)
psi_cluster <- distantia::distantia_cluster_hclust(
df = df_psi
)
names(psi_cluster)
reactable::reactable(
psi_cluster$df |>
mutate(silhouette_width = round(silhouette_width, 3)),
pagination = FALSE,
sortable = TRUE,
showSortable = TRUE,
filterable = TRUE,
resizable = TRUE,
defaultPageSize = nrow(psi_cluster$df),
showPageSizeOptions = TRUE,
striped = TRUE,
compact = TRUE,
wrap = FALSE,
fullWidth = TRUE
)
#number of clusters
k <- psi_cluster$clusters
factoextra::fviz_dend(
x = psi_cluster$cluster_object,
k = k,
k_colors = distantia::color_discrete(n = k),
cex = 1,
label_cols = "gray20",
rect = TRUE,
horiz = TRUE,
main = "",
ylab = "Dissimilarity"
)
sf_cluster <- dplyr::inner_join(
x = covid_counties[, "name"],
y = psi_cluster$df,
by = "name"
)
clustering <- mapview::mapview(
sf_cluster,
zcol = "cluster",
layer.name = "Cluster",
label = "name",
col.regions = distantia::color_discrete(n = k),
alpha.regions = distantia::f_rescale_local(
x = sf_cluster$silhouette_width,
new_min = 0.1
),
legend.position = "upperleft"
)
htmlwidgets::saveWidget(
clustering@map,
file = "clustering.html",
selfcontained = TRUE
)
rm(max_prevalence)
df_model <- distantia::distantia_model_frame(
response_df = df_psi,
predictors_df = covid_counties,
scale = FALSE
)
df_model |>
dplyr::mutate(
dplyr::across(
dplyr::where(is.numeric), ~ round(.x, 2)
)
) |>
reactable::reactable(
pagination = TRUE,
searchable = TRUE,
sortable = TRUE,
showSortable = TRUE,
filterable = TRUE,
resizable = TRUE,
defaultPageSize = 10,
showPageSizeOptions = TRUE,
striped = TRUE,
compact = TRUE,
wrap = FALSE,
fullWidth = TRUE
)
df_model <- distantia::distantia_model_frame(
response_df = df_psi,
predictors_df = covid_counties |>
dplyr::mutate(
density = population / area_hectares
),
composite_predictors = list(
economy = c(
"poverty_percentage",
"median_income",
"domestic_product",
"employed_percentage",
"daily_miles_traveled"
)
),
#scale = TRUE is broken in version <= 2.0.2
scale = FALSE
) |>
#selecting and renaming columns
dplyr::transmute(
psi,
economy,
density,
distance = geographic_distance
) |>
#scale
dplyr::mutate(
dplyr::across(
dplyr::all_of(c("economy", "density", "distance")),
~ as.numeric(scale(.x))
)
)
df_model |>
dplyr::mutate(
dplyr::across(
dplyr::where(is.numeric), ~ round(.x, 2)
)
) |>
reactable::reactable(
pagination = TRUE,
searchable = TRUE,
sortable = TRUE,
showSortable = TRUE,
filterable = TRUE,
resizable = TRUE,
defaultPageSize = 10,
showPageSizeOptions = TRUE,
striped = TRUE,
compact = TRUE,
wrap = FALSE,
fullWidth = TRUE
)
m <- stats::lm(
formula = psi ~ distance + density + economy,
data = df_model
)
m |>
summary() |>
broom::tidy() |>
dplyr::mutate(dplyr::across(dplyr::where(is.numeric), ~ round(.x, 4))) |>
dplyr::arrange(dplyr::desc(estimate)) |>
dplyr::filter(term != "(Intercept)") |>
reactable(
striped = TRUE,
fullWidth = TRUE,
resizable = TRUE,
sortable = TRUE,
showSortable = TRUE
)
par(mfrow = c(1, 3), cex.axis = 1.5, cex.lab = 2)
line_params <- list(col = "red4", lwd = 1)
visreg::visreg(
fit = m,
xvar = "distance",
line = line_params
)
visreg::visreg(
fit = m,
xvar = "economy",
line = line_params
)
visreg::visreg(
fit = m,
xvar = "density",
line = line_params
)
distantia::tsl_plot(tsl = tsl_smol, guide = FALSE)
distantia::distantia_dtw_plot(
tsl = tsl_smol[c("Napa", "San_Francisco")]
)
distantia::distantia_dtw_plot(
tsl = tsl_smol[c("San_Francisco", "Napa")]
)
df_delay <- distantia::distantia_time_delay(
tsl = tsl_smol[c("San_Francisco", "Napa")]
)
df_delay |>
dplyr::select(
-distance,
-sd
) |>
dplyr::mutate(
mean = round(mean, 1)
) |>
reactable(
fullWidth = TRUE,
resizable = TRUE,
sortable = TRUE,
showSortable = TRUE
)
tsl = tsl_smol[c("San_Francisco", "Napa")]
distance = "euclidean"
bandwidth = 1
two_way = FALSE
#check input arguments
args <- utils_check_args_distantia(
tsl = tsl,
distance = distance[1]
)
tsl <- args$tsl
distance <- args$distance
#tsl pairs
df <- utils_tsl_pairs(
tsl = tsl,
args_list = list(
distance = distance
)
)
#function to compute modal of differences
delay_modal <- function(x) {
ux <- unique(na.omit(x))
y <- ux[which.max(tabulate(match(x, ux)))][1]
class(y) <- class(x)
attr(x = y, which = "units") <- attributes(x)$units
y
}
i <- 1
df.i <- df[i, ]
#compute least cost path
cost_path.i <- cost_path_cpp(
x = tsl[[df.i[["x"]]]],
y = tsl[[df.i[["y"]]]],
distance = distance,
diagonal = TRUE,
weighted = TRUE,
ignore_blocks = FALSE,
bandwidth = bandwidth
)
#remove duplicates
cost_path.i <- cost_path.i[
!(duplicated(cost_path.i[["x"]]) |
duplicated(cost_path.i[["y"]])),
c("x", "y")
]
#compute 5% padding
padding <- ceiling(nrow(cost_path.i)/100) * 5
#compute n to assess if we apply padding
n <- nrow(cost_path.i) - (padding * 2)
if(n >= 30){
cost_path.i <- cost_path.i[padding:(nrow(cost_path.i)-padding),]
}
#check time series units
delay.time.i.units.x <- zoo_time(x = tsl[[df.i[["x"]]]])$units
delay.time.i.units.y <- zoo_time(x = tsl[[df.i[["y"]]]])$units
if(delay.time.i.units.x != delay.time.i.units.y){
warning(
"distantia::distantia_time_delay(): time series '",
df[["x"]], "' and '", df[["y"]], "' have different time units (",
delay.time.i.units.x,
" vs ",
delay.time.i.units.y,
". Computing time delay with units 'samples'."
)
delay.time.i.units <- "samples"
}
source("~/Dropbox/GITHUB/R_packages/distantia/R/distantia_time_delay.R")
df_delay <- distantia_time_delay(
tsl = tsl_smol[c("San_Francisco", "Napa")]
)
df_delay
df_delay <- distantia_time_delay(
tsl = tsl_smol[c("San_Francisco", "Napa")]
)
df_delay
tsl = tsl_smol[c("San_Francisco", "Napa")]
#check input arguments
args <- utils_check_args_distantia(
tsl = tsl,
distance = distance[1]
)
tsl <- args$tsl
distance <- args$distance
#tsl pairs
df <- utils_tsl_pairs(
tsl = tsl,
args_list = list(
distance = distance
)
)
#function to compute modal of differences
delay_modal <- function(x) {
ux <- unique(na.omit(x))
y <- ux[which.max(tabulate(match(x, ux)))][1]
class(y) <- class(x)
attr(x = y, which = "units") <- attributes(x)$units
y
}
iterations <- seq_len(nrow(df))
i <- 1
df.i <- df[i, ]
df.i
tsl[[df.i[["x"]]]]
tsl[[df.i[["y"]]]]
cost_path.i <- cost_path_cpp(
x = tsl[[df.i[["x"]]]],
y = tsl[[df.i[["y"]]]],
distance = distance,
diagonal = TRUE,
weighted = TRUE,
ignore_blocks = FALSE,
bandwidth = bandwidth
)
cost_path.i
cost_path.i <- cost_path.i[
!(duplicated(cost_path.i[["x"]]) |
duplicated(cost_path.i[["y"]])),
c("x", "y")
]
#compute 5% padding
padding <- ceiling(nrow(cost_path.i)/100) * 5
#compute n to assess if we apply padding
n <- nrow(cost_path.i) - (padding * 2)
if(n >= 30){
cost_path.i <- cost_path.i[padding:(nrow(cost_path.i)-padding),]
}
#check time series units
delay.time.i.units.x <- zoo_time(x = tsl[[df.i[["x"]]]])$units
delay.time.i.units.y <- zoo_time(x = tsl[[df.i[["y"]]]])$units
source("~/Dropbox/GITHUB/R_packages/distantia/R/distantia_time_delay.R")
df_delay <- distantia_time_delay(
tsl = tsl_smol[c("San_Francisco", "Napa")]
)
df_delay
View(df_delay)
df_delay <- distantia_time_delay(
tsl = tsl_smol[c("Napa", "San_Francisco")]
)
df_delay
View(df_delay)
