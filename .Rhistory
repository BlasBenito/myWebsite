m_cost[1:2, 1:2]
graphics::image(
x = seq_len(ncol(m_cost)),
y = seq_len(nrow(m_cost)),
z = m_cost,
xlab = "zoo_spain",
ylab = "zoo_sweden",
main = "Cost Matrix (work in progress)"
)
#iterate over rows of the cost matrix
for(row.i in 2:nrow(m_dist)){
#iterate over columns of the cost matrix
for(col.j in 2:ncol(m_dist)){
#get cost of neighbor with minimum accumulated cost
min_cost <- min(
m_cost[row.i - 1, col.j],
m_cost[row.i, col.j - 1]
)
#add it to the distance of the target cell
new_value <- min_cost + m_dist[row.i, col.j]
#fill the empty cell with the new value
m_cost[row.i, col.j] <- new_value
}
}
graphics::image(
x = seq_len(ncol(m_cost)),
y = seq_len(nrow(m_cost)),
z = m_cost,
xlab = "zoo_spain",
ylab = "zoo_sweden",
main = "Cost Matrix"
)
m <- nrow(m_cost)
n <- ncol(m_cost)
m_cost[(m-1):m, (n-1):n]
m_cost[m, n] <- m_cost[m, n] + m_cost[1, 1]
m_cost[(m-1):m, (n-1):n]
#' Cost Matrix from Distance Matrix
#' @param distance_matrix (required, matrix) distance matrix.
#' @return matrix
cost_matrix <- function(distance_matrix){
m <- matrix(
data = NA,
nrow = nrow(distance_matrix),
ncol = ncol(distance_matrix)
)
m[1, ] <- cumsum(distance_matrix[1, ])
m[, 1] <- cumsum(distance_matrix[, 1])
for(row in 2:nrow(distance_matrix)){
for(col in 2:ncol(distance_matrix)){
m[row, col] <- min(
m[row - 1, col],
m[row, col - 1]
) + distance_matrix[row, col]
}
}
m[row.i, col.j] <- m[row.i, col.j] + m[1, 1]
m
}
m_cost <- cost_matrix(distance_matrix = m_dist)
graphics::image(
x = seq_len(ncol(m_cost)),
y = seq_len(nrow(m_cost)),
z = m_cost,
xlab = "zoo_spain",
ylab = "zoo_sweden",
main = "Cost Matrix"
)
path <- data.frame(
row = ncol(m_cost),
col = nrow(m_cost)
)
path
steps <- list(
left = c(path$row, max(path$col - 1, 1)),
up = c(max(path$row - 1, 1), path$col)
)
steps
costs <- list(
left = m_cost[steps$left[1], steps$left[2]],
up = m_cost[steps$up[1], steps$up[2]]
)
costs
steps[[which.min(costs)[1]]]
#' Identify Next Step of Least-Cost Path
#' @param cost_matrix (required, matrix) cost matrix.
#' @param last_step (required, data frame) one row data frame with columns "row" and "col" representing the last step of a least-cost path.
#' @return one row data frame, new step in least-cost path
least_cost_step <- function(cost_matrix, last_step){
steps <- list(
left = c(last_step$row, max(last_step$col - 1, 1)),
up = c(max(last_step$row - 1, 1), last_step$col)
)
costs <- list(
left = cost_matrix[steps$left[1], steps$left[2]],
up = cost_matrix[steps$up[1], steps$up[2]]
)
coords <- steps[[which.min(costs)[1]]]
#rewrite input with new values
new_step <- last_step
new_step[,] <- c(coords[1], coords[2])
new_step
}
least_cost_step(
cost_matrix = m_cost,
last_step = path
)
repeat{
#find next step
new.step <- least_cost_step(
cost_matrix = m_cost,
last_step = tail(path, n = 1)
)
#join the new step with path
path <- rbind(
path, new.step,
make.row.names = FALSE
)
#stop when coordinates are 1, 1
if(all(tail(path, n = 1) == 1)){break}
}
path
graphics::image(
x = seq_len(ncol(m_cost)),
y = seq_len(nrow(m_cost)),
z = m_cost,
xlab = "zoo_spain",
ylab = "zoo_sweden",
main = "Cost Matrix and Least-Cost Path"
)
graphics::lines(
x = path$row,
y = path$col,
lwd = 2
)
#' Least-Cost Path from Cost Matrix
#' @param cost_matrix (required, matrix) cost matrix.
#' @return data frame with least-cost path coordinates
least_cost_path <- function(cost_matrix){
#first step of the least cost path
path <- data.frame(
row = ncol(cost_matrix),
col = nrow(cost_matrix)
)
#iterate until path is completed
repeat{
#merge path with result of least_cost_step()
path <- rbind(
path,
#find next step
least_cost_step(
cost_matrix = cost_matrix,
last_step = tail(path, n = 1)
),
make.row.names = FALSE
)
#stop when coordinates are 1, 1
if(all(tail(path, n = 1) == 1)){break}
}
path
}
least_cost_path(cost_matrix = m_cost)
path_matrix <- as.matrix(path[, c("row", "col")])
distances <- m_dist[path_matrix]
distances
distance <- sum(distances)
distance
n <- nrow(zoo_sweden) + nrow(zoo_spain)
n
normalizer <- sum(dim(m_dist))
normalizer
distance/normalizer
#' Similarity Metric from Least Cost Path and Cost Matrix
#' @param cost_path (required, data frame) least cost path with the columns "row" and "col".
#' @param distance_matrix (required, matrix) distance matrix
#' @return numeric, similarity metric
similarity_score <- function(cost_path, distance_matrix){
#convert least-cost path to matrix
cost_path_matrix <- as.matrix(path[, c("row", "col")])
#extract distances from the distance matrix
distances <- distance_matrix[cost_path_matrix]
#sum distances
distance <- sum(distances)
#compute normalization factor from matrix dimensions
normalizer <- sum(dim(distance_matrix))
#compute similarity
score <- distance/normalizer
score
}
similarity_score(
cost_path = path,
distance_matrix = m_dist
)
#' Similarity Between Time Series
#' @param a (required, zoo object) time series.
#' @param b (required, zoo object) time series with same columns as `x`
#' @param plot (optional, logical) if `TRUE`, a dynamic time warping plot is produced.
#' @return value, similarity metric
dynamic_time_warping <- function(a, b, plot = TRUE){
#linear detrending and z-score normalization
a_ <- ts_preprocessing(x = a)
b_ <- ts_preprocessing(x = b)
#distance matrix
dist_matrix <- distance_matrix(
a = a_,
b = b_
)
#cost matrix
cost_matrix <- cost_matrix(
distance_matrix = dist_matrix
)
#least-cost path
cost_path <- least_cost_path(
cost_matrix = cost_matrix
)
#similarity metric
score <- similarity_score(
cost_path = cost_path,
distance_matrix = dist_matrix
)
#plot
if(plot == TRUE){
graphics::image(
x = seq_len(ncol(cost_matrix)),
y = seq_len(nrow(cost_matrix)),
z = m_cost,
xlab = "a",
ylab = "b",
main = paste0("Similarity score = ", round(score, 3))
)
graphics::lines(
x = cost_path$row,
y = cost_path$col,
lwd = 2
)
}
score
}
#' Similarity Between Time Series
#' @param a (required, zoo object) time series.
#' @param b (required, zoo object) time series with same columns as `x`
#' @param plot (optional, logical) if `TRUE`, a dynamic time warping plot is produced.
#' @return value, similarity metric
dynamic_time_warping <- function(a, b, plot = TRUE){
#linear detrending and z-score normalization
a_ <- ts_preprocessing(x = a)
b_ <- ts_preprocessing(x = b)
#distance matrix
m_dist <- distance_matrix(
a = a_,
b = b_
)
#cost matrix
m_cost <- cost_matrix(
distance_matrix = m_dist
)
#least-cost path
cost_path <- least_cost_path(
cost_matrix = m_cost
)
#similarity metric
score <- similarity_score(
cost_path = cost_path,
distance_matrix = m_dist
)
#plot
if(plot == TRUE){
graphics::image(
x = seq_len(ncol(m_cost)),
y = seq_len(nrow(m_cost)),
z = m_cost,
xlab = "a",
ylab = "b",
main = paste0("Similarity score = ", round(score, 3))
)
graphics::lines(
x = cost_path$row,
y = cost_path$col,
lwd = 2
)
}
score
}
dynamic_time_warping(
a = zoo_spain,
b = zoo_spain
)
library(dtw)
xy_dtw <- dtw::dtw(
x = ts_preprocessing(x = zoo_spain),
y = ts_preprocessing(x = zoo_sweden),
keep = TRUE
)
plot(xy_dtw, type = "threeway")
xy_dtw
xy_dtw$distance
path_matrix <- as.matrix(path[, c("row", "col")])
distances <- m_dist[path_matrix]
distances
distance <- sum(distances)
distance
m_cost[13, 13]
m_cost[13, 13] - m_cost[1, 1]
help(dtw)
path_matrix <- as.matrix(path[, c("row", "col")])
distances <- m_dist[path_matrix]
distances
distance <- sum(distances)
distance
distance <- m_cost[nrow(m_cost), ncol(m_cost)] - m_cost[1, 1]
distance <- m_cost[nrow(m_cost), ncol(m_cost)] - m_cost[1, 1]
distance
normalizer <- nrow(path)
normalizer
distance/normalizer
#' Similarity Metric from Least Cost Path and Cost Matrix
#' @param cost_path (required, data frame) least cost path with the columns "row" and "col".
#' @param cost_matrix (required, matrix) cost matrix
#' @return numeric, similarity metric
similarity_score <- function(cost_path, cost_matrix){
#sum distances
distance <- m_cost[nrow(cost_matrix), ncol(cost_matrix)] - m_cost[1, 1]
#compute normalization factor from matrix dimensions
normalizer <- nrow(cost_path)
#compute similarity
score <- distance/normalizer
score
}
similarity_score(
cost_path = path,
cost_matrix = m_cost
)
#' Similarity Between Time Series
#' @param a (required, zoo object) time series.
#' @param b (required, zoo object) time series with same columns as `x`
#' @param plot (optional, logical) if `TRUE`, a dynamic time warping plot is produced.
#' @return value, similarity metric
dynamic_time_warping <- function(a, b, plot = TRUE){
#linear detrending and z-score normalization
a_ <- ts_preprocessing(x = a)
b_ <- ts_preprocessing(x = b)
#distance matrix
m_dist <- distance_matrix(
a = a_,
b = b_
)
#cost matrix
m_cost <- cost_matrix(
distance_matrix = m_dist
)
#least-cost path
cost_path <- least_cost_path(
cost_matrix = m_cost
)
#similarity metric
score <- similarity_score(
cost_path = cost_path,
cost_matrix = m_cost
)
#plot
if(plot == TRUE){
graphics::image(
x = seq_len(ncol(m_cost)),
y = seq_len(nrow(m_cost)),
z = m_cost,
xlab = "a",
ylab = "b",
main = paste0("Similarity score = ", round(score, 3))
)
graphics::lines(
x = cost_path$row,
y = cost_path$col,
lwd = 2
)
}
score
}
dynamic_time_warping(
a = zoo_spain,
b = zoo_spain
)
library(dtw)
xy_dtw <- dtw::dtw(
x = ts_preprocessing(x = zoo_spain),
y = ts_preprocessing(x = zoo_sweden),
keep = TRUE
)
library(dtw)
xy_dtw <- dtw::dtw(
x = ts_preprocessing(x = zoo_spain),
y = ts_preprocessing(x = zoo_sweden),
keep = TRUE
)
xy_dtw$normalizedDistance
xy_dtw$costMatrix
m_cost
a = zoo_spain
b = zoo_spain
#linear detrending and z-score normalization
a_ <- ts_preprocessing(x = a)
b_ <- ts_preprocessing(x = b)
#distance matrix
m_dist <- distance_matrix(
a = a_,
b = b_
)
#cost matrix
m_cost <- cost_matrix(
distance_matrix = m_dist
)
library(dtw)
xy_dtw <- dtw::dtw(
x = ts_preprocessing(x = zoo_spain),
y = ts_preprocessing(x = zoo_spain),
keep = TRUE
)
xy_dtw$normalizedDistance
xy_dtw$costMatrix
image(xy_dtw$costMatrix)
image(xy_dtw$costMatrix)
image(m_cost)
xy_dtw$stepPattern
help(dtw)
library(dtw)
xy_dtw <- dtw::dtw(
x = ts_preprocessing(x = zoo_spain),
y = ts_preprocessing(x = zoo_spain),
step.pattern = "asymmetric",
keep = TRUE
)
dynamic_time_warping(
a = zoo_spain,
b = zoo_spain
)
dynamic_time_warping(
a = zoo_spain,
b = zoo_sweden
)
a = zoo_spain
b = zoo_sweden
a_ <- ts_preprocessing(x = a)
b_ <- ts_preprocessing(x = b)
a_
b_
m_dist <- distance_matrix(
a = a_,
b = b_
)
image(m_dist)
m_cost <- cost_matrix(
distance_matrix = m_dist
)
image(m_cost)
cost_path <- least_cost_path(
cost_matrix = m_cost
)
score <- similarity_score(
cost_path = cost_path,
cost_matrix = m_cost
)
score
graphics::image(
x = seq_len(ncol(m_cost)),
y = seq_len(nrow(m_cost)),
z = m_cost,
xlab = "a",
ylab = "b",
main = paste0("Similarity score = ", round(score, 3))
)
graphics::lines(
x = cost_path$row,
y = cost_path$col,
lwd = 2
)
graphics::image(
x = seq_len(ncol(m_cost)),
y = seq_len(nrow(m_cost)),
z = m_cost,
xlab = "a",
ylab = "b",
main = paste0("Similarity score = ", round(score, 3))
)
graphics::lines(
x = cost_path$row,
y = cost_path$col,
lwd = 2
)    graphics::image(
graphics::image(
x = seq_len(ncol(m_cost)),
y = seq_len(nrow(m_cost)),
z = m_cost,
xlab = "a",
ylab = "b",
main = paste0("Similarity score = ", round(score, 3))
)
graphics::lines(
x = cost_path$row,
y = cost_path$col,
lwd = 2
)
dynamic_time_warping(
a = zoo_spain,
b = zoo_spain
)
dynamic_time_warping(
a = zoo_spain,
b = zoo_spain
)
dynamic_time_warping(
a = zoo_spain,
b = zoo_sweden
)
