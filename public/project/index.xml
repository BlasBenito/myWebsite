<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Projects | Blas M. Benito</title>
    <link>/project/</link>
      <atom:link href="/project/index.xml" rel="self" type="application/rss+xml" />
    <description>Projects</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sat, 02 Jan 2021 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/media/avatar.jpg</url>
      <title>Projects</title>
      <link>/project/</link>
    </image>
    
    <item>
      <title>Palaeo fire modeling</title>
      <link>/project/palaeo_fire_modeling/</link>
      <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
      <guid>/project/palaeo_fire_modeling/</guid>
      <description>&lt;p&gt;This is a spatio-temporal simulation of the effect of fire regimes on the population dynamics of five forest species (Pinus sylvestris, Pinus uncinata, Betula pendula, Corylus avellana, and Quercus petraea) during the Lateglacial-Holocene transition (15-7 cal Kyr BP) at El Portalet, a subalpine bog located in the central Pyrenees region (1802m asl, Spain), that has served for palaeoenvironmental studies (González-Smapériz et al. 2006; Gil-Romera et al., 2014). This model is described in the paper in prep. titled &lt;em&gt;Forest - fire interactions in the Central Pyrenees: a data-model comparison for the Lateglacial-Holocene transition&lt;/em&gt;, and authored by Graciela Gil-Romera, Blas M. Benito, Juli G. Pausas, Penélope González-Sampériz, J. Julio. Camarero, Jens-Christian Svenning, and Blas Valero-Garcés.&lt;/p&gt;
&lt;p&gt;A short description of the project was presented by 
&lt;a href=&#34;https://gilromera.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Graciela Gil-Romera&lt;/a&gt; at the 
&lt;a href=&#34;https://twitter.com/QUAPAL_18&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;1st Quaternary Palaeoecology Twitter Conference&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;1 &lt;a href=&#34;https://twitter.com/hashtag/QUAPAL18?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#QUAPAL18&lt;/a&gt;  [Coauthored by P. González-Sampériz &lt;a href=&#34;https://twitter.com/jgpausas?ref_src=twsrc%5Etfw&#34;&gt;@jgpausas&lt;/a&gt; &lt;a href=&#34;https://twitter.com/2xeu?ref_src=twsrc%5Etfw&#34;&gt;@2xeu&lt;/a&gt; &lt;a href=&#34;https://twitter.com/JCSvenning?ref_src=twsrc%5Etfw&#34;&gt;@JCSvenning&lt;/a&gt; @Blas_Valero_Garces] &lt;a href=&#34;https://twitter.com/hashtag/Palaeofire?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Palaeofire&lt;/a&gt; tells us a lot on past  burnt biomass, emissions &amp;amp; human impact (&lt;a href=&#34;https://t.co/biSuzCKWjX&#34;&gt;https://t.co/biSuzCKWjX&lt;/a&gt;) We lack though a good understanding of past  fire-vegetation interactions. &lt;a href=&#34;https://t.co/zEWaTpcKe3&#34;&gt;pic.twitter.com/zEWaTpcKe3&lt;/a&gt;&lt;/p&gt;&amp;mdash; Graciela Gil-Romera (@gilromera) &lt;a href=&#34;https://twitter.com/gilromera/status/1006865146189410305?ref_src=twsrc%5Etfw&#34;&gt;June 13, 2018&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;how-does-it-work&#34;&gt;HOW DOES IT WORK&lt;/h3&gt;
&lt;h4 id=&#34;abiotic-component&#34;&gt;Abiotic component&lt;/h4&gt;
&lt;p&gt;The abiotic layer of the model is represented by three main environmental factors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Topography&lt;/strong&gt; derived from a digital elevation model at 200 x 200 meters resolution. Slope (along temperature) is used to impose restrictions to species distributions. Northness (in the range [0, 1]) is used to restrict fire spread. Aspect is used to draw a shaded relief map (at the user&amp;rsquo;s request). Elevation is used to compute a lapse rate map (see below).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Temperature&lt;/strong&gt; (average of montly minimum temperatures) time series for the study area computed from palaeoclimatic data at annual resolution provided by the 
&lt;a href=&#34;http://www.cgd.ucar.edu/ccr/TraCE/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TraCe simulation&lt;/a&gt;, a transient model for the global climate evolution of the last 21K years with an annual resolution. The single temperature value of every year is converted into a temperature map (200 x 200 m resolution) using a lapse rate map based on the elevation map. Temperature, along with slope, is used to compute habitat suitability by using a logistic equation. Habitat suitability affects plant growth and survival.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Fire&lt;/strong&gt;: The charcoal accumulation rate record (CHAR) from El Portalet palaeoenvironmental sequence (Gil-Romera et al., 2014) is used as input to simulate forest fires. A value of this time series is read each year, and a random number in the range [0, 1] is generated. If the random number is lower than the &lt;em&gt;Fire-probability-per-year&lt;/em&gt; (FPY) parameter defined by the user, the value from the charcoal time series is multiplied by the parameter &lt;em&gt;Number-ignitions-per-fire-event&lt;/em&gt; (NIF) (defined by the user) to compute the number of ignitions for the given year. As many adult tree as ignitions are selected to start spreading fire. Fire spreads to a neighbor patch if there is an adult tree in there, and a random number in the range [0, 1] is higher than the northness value of the patch.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;biotic-component&#34;&gt;Biotic component&lt;/h4&gt;
&lt;p&gt;The biotic layer of the model is composed by five tree species. We have introduced the following elements to represent their ecological dynamics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Topoclimatic niche&lt;/strong&gt;, inferred from their present day distributions and high resolution temperature maps (presence data taken from GBIF, temperature maps taken from Worldclim and the Digital Climatic Atlas of the Iberian Peninsula). The ecological niche is represented by a logistic equation (see below). The results of this equation plus the dispersal dynamics of each species defines changes in distribution over time.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Population dynamics&lt;/strong&gt;, driven by species traits such as dispersal distance, longevity, fecundity, mortality, growth rate, post-fire response to fire, and heliophity (competition for light). The data is based on the literature and/or expert opinion from forest and fire ecologists, and it is used to simulate growth (using logistic equations), competition for light and space, decay due to senescence, and mortality due to climate, fire, or plagues.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The model doesn&amp;rsquo;t simulate the entire populations of the target species. Instead, on each 200 x 200 meters patch it simulates the dynamics of an small forest plot (around 10 x 10 meters) where a maximum of one individual per species can exist.&lt;/p&gt;
&lt;h4 id=&#34;model-dynamics&#34;&gt;Model dynamics&lt;/h4&gt;
&lt;iframe src=&#34;https://player.vimeo.com/video/274750111&#34; width=&#34;640&#34; height=&#34;424&#34; frameborder=&#34;0&#34; allow=&#34;autoplay; fullscreen&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href=&#34;https://vimeo.com/274750111&#34;&gt;Let&amp;rsquo;s burn it! Simulating fire-vegetation dynamics at millennial timescales in the central Pyrenees.&lt;/a&gt; from &lt;a href=&#34;https://vimeo.com/blasbenito&#34;&gt;blas benito&lt;/a&gt; on &lt;a href=&#34;https://vimeo.com&#34;&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The life of an individual&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;During the model setup seeds of every species are created on every patch. From there, every seed will go through the following steps every simulated year:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Its age increases by one year, and its life-stage is changed to &amp;ldquo;seedling&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The minimum average temperature of its patch is updated.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The individual computes its habitat suitability using the logistic equation &lt;em&gt;1 / ( 1 + exp( -(intercept + coefficient * patch-temperature)))&lt;/em&gt;, where the &lt;em&gt;intercept&lt;/em&gt; and the &lt;em&gt;coefficient&lt;/em&gt; are user defined. These parameters are hardcoded to save space in the GUI, and have been computed beforehand by using current presence data and temperature maps.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If habitat suitability is higher than a random number in the range [0, 1], the habitat is considered suitable (NOTE: this random number is defined for the patch, and it changes every ~10 years following a random walk drawn from a normal distribution with the average set to the previous value, and a standard deviation of 0.001).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If it is lower, the habitat is considered unsuitable, and the number of years under unsuitable habitat is increased by 1.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the number of years unders unsuitable habitat becomes higher than &lt;em&gt;seedling-tolerance&lt;/em&gt;, the seedling dies, and another seed from the seed bank takes its place. Otherwise it stays alive.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mortality: If a random number in the range [0, 1] is lower than the seedling mortality of the species the plant dies, and it is replaced by a seed from the seed bank. Otherwise it stays alive.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Competition and growth:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If the patch total biomass of the individuals in the patch equals &lt;em&gt;Max-biomass-per-patch&lt;/em&gt;, the individual loses an amount of biomass between 0 and the 20% of its current biomass. This number is randomly selected.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If &lt;em&gt;Max-biomass-per-patch&lt;/em&gt; has not been reached yet:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;An &lt;em&gt;interaction term&lt;/em&gt; is computed as &lt;em&gt;(1 - (biomass of other individuals in the patch / Max-biomass-per-patch)) * (1 - heliophilia))&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The interaction term is introduced in the growth equation &lt;em&gt;max-biomass / (1 + max-biomass * exp(- growth-rate * interaction-term * habitat-suitability * age))&lt;/em&gt; to compute the current biomass of the individual. The lower the interaction term and habitat suitability are, the lower the growth becomes.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If a fire reaches the patch and there are adult individuals of other species on it, the plant dies, and it is replaced by a seed (this seed inherites the traits of the parent).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These steps continue while the individual is still a seedling, but once it reaches its maturity some steps become slightly different:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If a random number in the range [0, 1] is lower than the adults mortality of the species, or the maximum age of the species is reached, the individual is marked for decay. The current biomass of decaying individuals is computed as &lt;em&gt;previous-biomass - years-of-decay&lt;/em&gt;. To add the effect of climatic variability to this decreasing function, its result is multiplied by &lt;em&gt;1 - habitat-suitability x random[0, 10]&lt;/em&gt;. If the biomass is higher than zero, pollen productivity is computed as &lt;em&gt;current-biomass x species-pollen-productivity&lt;/em&gt;. The individual dies and is replaced by a seed when the biomass is below 1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dispersal: If the individual is in suitable habitat, a seed from it is placed in one of the neighboring patches within a radius given by the dispersal distance of the species (which is measured in &amp;ldquo;number of patches&amp;rdquo; and hardcoded) with no individuals of the same species.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the individual starts a fire, or if fire spreads in from neighboring patches, it is marked as &amp;ldquo;burned&amp;rdquo;, spreads fire to its neighbors, dies, and is replaced by a seed. If the individual belongs to an species with post-fire resprouting, the growth-rate of the seed is multiplied by 2 to boost growth after fire.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Simulating pollen and charcoal deposition&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The user defines the radius of a catchment area round the core location (10 km by default, that is 50 patches). All patches within this radius define the RSAP (relevant source area of pollen).&lt;/p&gt;
&lt;p&gt;At the end of every simulated year the pollen productivity of every adult of each species within the RSAP is summed, and this value is used to compose the simulated pollen curves. The same is done with the biomass of the burned individuals to compose the virtual charcoal curve.&lt;/p&gt;
&lt;h4 id=&#34;output&#34;&gt;Output&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;In GUI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The simulation GUI shows the following results in real time:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Plots of the input values:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Minimum Temperature of the coldest month.&lt;/li&gt;
&lt;li&gt;Real charcoal data.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Simulated pollen curves for the target taxa.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Simulated charcoal curve.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Map showing the distribution of every species and the forest fires.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Written to disk&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The simulated pollen counts and charcoal is exported to the path defined by the user as a table in csv format named &lt;strong&gt;output_table.csv&lt;/strong&gt;. It contains one row per simulated year and the following columns:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;age: simulated year.&lt;/li&gt;
&lt;li&gt;temperature_minimum_average: average minimum winter temperature of the study area.&lt;/li&gt;
&lt;li&gt;pollen_Psylvestris: pollen sum for Pinus sylvestris.&lt;/li&gt;
&lt;li&gt;pollen_Puncinata&lt;/li&gt;
&lt;li&gt;pollen_Bpendula&lt;/li&gt;
&lt;li&gt;pollen_Cavellana&lt;/li&gt;
&lt;li&gt;pollen_Qpetraea&lt;/li&gt;
&lt;li&gt;real_charcoal: real charcoal values from El Portalet core.&lt;/li&gt;
&lt;li&gt;ignitions: number of fire ignitions.&lt;/li&gt;
&lt;li&gt;charcoal_sum: biomass sum of all burned individuals.&lt;/li&gt;
&lt;li&gt;charcoal_Psylvestris: sum of the biomass of burned individuals of Pinus sylvestris.&lt;/li&gt;
&lt;li&gt;charcoal_Puncinata&lt;/li&gt;
&lt;li&gt;charcoal_Bpendula&lt;/li&gt;
&lt;li&gt;charcoal_Cavellana&lt;/li&gt;
&lt;li&gt;charcoal_Qpetraea&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Snapshots of the simulation map taken at 1 or 10 years intervals are stored in the output folder is requested by the user. These snapshots are useful to compose a video of the simulation.&lt;/p&gt;
&lt;h3 id=&#34;how-to-use-it&#34;&gt;HOW TO USE IT&lt;/h3&gt;
&lt;h4 id=&#34;input-files&#34;&gt;Input files&lt;/h4&gt;
&lt;p&gt;Input files are stored in a folder named &amp;ldquo;data&amp;rdquo;. These are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;age&lt;/strong&gt;: text file with no extension and a single column with no header containing age values from -15000 to -5701&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fire&lt;/strong&gt;: text file with no extension and a single column with no header containing actual charcoal counts expresed in the range [0, 1]. There are as many rows as in the &lt;strong&gt;age&lt;/strong&gt; file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;t_minimum_average&lt;/strong&gt;: text file with same features as the ones above containing minimum winter temperatures for the study area extracted from the TraCe simualtion.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;correct_t_minimum_average.asc&lt;/strong&gt;: Map at 200m resolution containing the minimum winter temperature difference (period 1970-2000) between the TraCe simulation and the Digital Climatic Atlas of the Iberian Peninsula. It is used to transform the values of &lt;strong&gt;t_minimum_average&lt;/strong&gt; into a high resolution temperature map.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;elevation.asc&lt;/strong&gt;: digital elevation model of the study area at 200m resolution, coordinate system with EPSG code 23030.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slope.asc&lt;/strong&gt;: topographic slope.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;topography.asc&lt;/strong&gt;: shaded relief map. It is used for plotting purposes only.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;input-parameters&#34;&gt;Input parameters&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;General configuration of the simulation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The user can set-up the following parameters throught the GUI controls.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Output-path&lt;/strong&gt;: Character. Path of the output folder. This parameter cannot be empty, and the output folder must exist.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Snapshots?&lt;/strong&gt;: Boolean. If on, creates snapshots of the GUI to make videos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Snapshots-frequency&lt;/strong&gt;: Character. Defines the frequency of snapshots. Only two options: &amp;ldquo;every year&amp;rdquo; and &amp;ldquo;every 10 years&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Draw-topography?&lt;/strong&gt;: Boolean. If on, plots a shaded relief map (stored in &lt;strong&gt;topography.asc&lt;/strong&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RSAP-radius&lt;/strong&gt;: Numeric[5, 50]. Radius of the RSAP in number of patches. Each patch is 200 x 200 m, so an RSAP-radius of 10 equals 2 kilometres.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Randommness-settings&lt;/strong&gt;: Character. Allows to choose between &amp;ldquo;fixed seed&amp;rdquo; to obtain deterministic results, or &amp;ldquo;free seed&amp;rdquo; to obtain different results on each run.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Max-biomass-per-patch&lt;/strong&gt;: Numeric, integer. Maximum charge capacity of a patch.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fire?&lt;/strong&gt;: Boolean. If on, fires are produced whenever the data &lt;strong&gt;fire&lt;/strong&gt; triggers a fire event. If off, fires are not produced (control simulation).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fire-probability-per-year&lt;/strong&gt;: Numeric [0, 1]. Whenever the &lt;strong&gt;fire&lt;/strong&gt; file provides a number higher than 0, if a random number in the range [0, 1] is lower than &lt;strong&gt;Fire-probability-per-year&lt;/strong&gt;, a number of ignitions is computed (see below) and fires are triggered.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fire-ignitions-amplification-factor&lt;/strong&gt;: Numeric  The &lt;strong&gt;fire&lt;/strong&gt; file provides values in the range [0, 1], and this multiplication factor converts these values in an integer number of ignitions. If &lt;strong&gt;fire&lt;/strong&gt; equals one, and &lt;strong&gt;Fire-ignitions-amplification-factor&lt;/strong&gt; equals 10, the number of ignitions will be 10 for the given year.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mortality?&lt;/strong&gt;: Boolean. If on, mortality due to predation, plagues and other unpredictable sources is active (see &lt;strong&gt;Xx-seedling-mortality&lt;/strong&gt; and &lt;strong&gt;Xx-adult-mortality&lt;/strong&gt; parameters below).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Burn-in-iterations&lt;/strong&gt;: Numeric, integer. Number of years to run the model at a constant temperature (the initial one in the &lt;strong&gt;t_minimum_average&lt;/strong&gt; file) and no fires to allow the population model to reach an equilibrium before to start the actual simulation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P.sylvestris?&lt;/strong&gt;, &lt;strong&gt;P.uncinata?&lt;/strong&gt;, &lt;strong&gt;B.pendula?&lt;/strong&gt;, &lt;strong&gt;Q.petraea?&lt;/strong&gt;, and &lt;strong&gt;C.avellana?&lt;/strong&gt;: Boolean. If off, the given species is removed from the simulation. Used for testing purposes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Species traits&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Each species has a set of traits to be filled by the user. Note that a particular species can be removed from the simulation by switching it to &amp;ldquo;off&amp;rdquo;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Xx-max-age&lt;/strong&gt;: Numeric, integer. Maximum longevity. Every individual reaching this age is marked for decay.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-maturity-age&lt;/strong&gt;: Numeric, integer. Age of sexual maturity. Individuals reaching this age are considered adults.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-pollen-productivity&lt;/strong&gt;: Numeric. Multiplier of biomass to obtain a relative measure of pollen productivity among species.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-growth-rate&lt;/strong&gt;: Numeric. Growth rate of the given species.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-max-biomass&lt;/strong&gt;: Numeric, integer. Maximum biomass reachable by the given species.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-heliophilia&lt;/strong&gt;: Numeric, [0, 1]. Dependance of the species on solar light to grow. It is used to compute the effect of competence in plant growth.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-seedling-tolerance&lt;/strong&gt;: Numeric, integer. Numer of years a seedling can tolerate unsuitable climate.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-adult-tolerance&lt;/strong&gt;: Numeric, integer. Numer of years an adult can tolerate unsuitable climate.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-seedling-mortality&lt;/strong&gt;: Numeric, [0, 1]. Proportion of seedlings dying due to predation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-adult-mortality&lt;/strong&gt;: Numeric, [0, 1]. Proportion of adults dying due to plagues or other mortality sources.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-resprout-after-fire&lt;/strong&gt;: Boolean. If 0 the species doesn&amp;rsquo;t show a post-fire response. If 1, &lt;strong&gt;growth-rate&lt;/strong&gt; is multiplied by two in the resprouted individual to increase growth rate.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-min-temperature&lt;/strong&gt;: Numeric. Minimum temperature at which the species has been found using GBIF presence data.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-max-temperature&lt;/strong&gt;: Numeric. Maximum temperature at which the species has been found using GBIF presence data.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-min-slope&lt;/strong&gt;: Numeric. Minimum topographic slope at which the species has been found.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-max-slope&lt;/strong&gt;: Numeric. Maximum topographic slope at which the species has been found.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-intercept&lt;/strong&gt;: Numeric. Intercept of the logistic equation to compute habitat suitability fitted to presence data and minimum temperature maps.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Xx-coefficient&lt;/strong&gt;: Numeric. Coefficient of the logistic equation to compute habitat suitability.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Range-shift simulation</title>
      <link>/project/quercus_range_shift/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      <guid>/project/quercus_range_shift/</guid>
      <description>&lt;p&gt;This Netlogo model simulates the dispersal of Quercus pyrenaica populations in Sierra Nevada (Spain) at a yearly resolution until 2100 while considering different levels of model complexity, from random dispersal and seedling establishment, to realistic dispersal based on the dispersal behavior of the Eurasian Jay.&lt;/p&gt;
&lt;p&gt;The data required to run the model can be downloaded from 
&lt;a href=&#34;https://www.dropbox.com/s/zsjja2g3yrgqyl1/data.zip?dl=1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;. It must be decompressed in the same folder containing the netlogo code of the model.&lt;/p&gt;
&lt;p&gt;The video below shows the model in action for one population of &lt;em&gt;Quercus pyrenaica&lt;/em&gt;. On the left, it shows the effect of a random dispersal model, and on the right, a realistic dispersal model based on observations of the dispersal behavior of the Eurasian Jay.&lt;/p&gt;
&lt;iframe src=&#34;https://player.vimeo.com/video/66052823&#34; width=&#34;640&#34; height=&#34;363&#34; frameborder=&#34;0&#34; allow=&#34;autoplay; fullscreen&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>R package &#34;distantia&#34;</title>
      <link>/project/distantia/</link>
      <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
      <guid>/project/distantia/</guid>
      <description>&lt;!-- badges: start --&gt;
&lt;p&gt;
&lt;a href=&#34;https://zenodo.org/badge/latestdoi/187805264&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://zenodo.org/badge/187805264.svg&#34; alt=&#34;DOI&#34;&gt;&lt;/a&gt;

&lt;a href=&#34;https://CRAN.R-project.org/package=distantia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version-ago/distantia&#34; alt=&#34;CRAN\_Release\_Badge&#34;&gt;&lt;/a&gt;

&lt;a href=&#34;https://CRAN.R-project.org/package=distantia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://cranlogs.r-pkg.org/badges/distantia&#34; alt=&#34;CRAN\_Download\_Badge&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;!-- badges: end --&gt;
&lt;p&gt;The package &lt;em&gt;distantia&lt;/em&gt; allows to measure the dissimilarity between multivariate time-series. The package assumes that the target sequences are ordered along a given dimension, being depth and time the most common ones, but others such as latitude or elevation are also possible. Furthermore, the target time-series can be regular or irregular, and have their samples aligned (same age/time/depth) or unaligned (different age/time/depth). The only requirement is that the sequences must have at least two (but ideally more) columns with the same name and units representing different variables relevant to the dynamics of a system of interest.&lt;/p&gt;
&lt;p&gt;The 
&lt;a href=&#34;https://github.com/BlasBenito/distantia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub page&lt;/a&gt; of the project contains a thorough explanation of the statistics behind the method. The 
&lt;a href=&#34;https://onlinelibrary.wiley.com/doi/full/10.1111/ecog.04895&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;paper published in the Ecography journal&lt;/a&gt; describes the method, the package, and a couple of practical examples. The code and data used to develop the examples can be found in 
&lt;a href=&#34;https://github.com/BlasBenito/distantiaPaper&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; and 
&lt;a href=&#34;https://zenodo.org/record/3520959#.X94GNtYo-1c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Zenodo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Please, if you find this package useful, please cite it as:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Benito, B.M. and Birks, H.J.B. (2020), distantia: an open‐source toolset to quantify dissimilarity between multivariate ecological time‐series. Ecography, 43: 660-667. &lt;a href=&#34;https://doi.org/10.1111/ecog.04895&#34;&gt;https://doi.org/10.1111/ecog.04895&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>R package &#34;memoria&#34;</title>
      <link>/project/memoria/</link>
      <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
      <guid>/project/memoria/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;https://zenodo.org/badge/latestdoi/179102027&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://zenodo.org/badge/179102027.svg&#34; alt=&#34;DOI&#34;&gt;&lt;/a&gt;

&lt;a href=&#34;https://CRAN.R-project.org/package=memoria&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version-ago/memoria&#34; alt=&#34;CRAN\_Release\_Badge&#34;&gt;&lt;/a&gt;

&lt;a href=&#34;https://CRAN.R-project.org/package=memoria&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://cranlogs.r-pkg.org/badges/memoria&#34; alt=&#34;CRAN\_Download\_Badge&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The goal of &lt;em&gt;memoria&lt;/em&gt; is to provide the tools to quantify &lt;strong&gt;ecological
memory&lt;/strong&gt; in long time-series involving environmental drivers and biotic
responses, including palaeoecological datasets.&lt;/p&gt;
&lt;p&gt;Ecological memory has two main components: the &lt;em&gt;endogenous&lt;/em&gt; component,
which represents the effect of antecedent values of the response on
itself, and &lt;em&gt;endogenous&lt;/em&gt; component, which represents the effect of
antecedent values of the driver or drivers on the current state of the
biotic response. Additionally, the &lt;em&gt;concurrent effect&lt;/em&gt;, which represents
the synchronic effect of the environmental drivers over the response is
measured. The functions in the package allow the user&lt;/p&gt;
&lt;p&gt;The package &lt;em&gt;memoria&lt;/em&gt; uses the fast implementation of Random Forest
available in the 
&lt;a href=&#34;https://CRAN.R-project.org/package=ranger&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ranger&lt;/a&gt;
package to fit a model of the form shown in &lt;strong&gt;Equation 1&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Equation 1&lt;/strong&gt; (simplified from the one in the paper):
$$p_{t} = p_{t-1} +&amp;hellip;+ p_{t-n} + d_{t} + d_{t-1} +&amp;hellip;+ d_{t-n}$$&lt;/p&gt;
&lt;p&gt;Where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$p$ is the response variable, &lt;em&gt;Pollen&lt;/em&gt; counts were used in this particular case..&lt;/li&gt;
&lt;li&gt;$d$ is an environmental &lt;em&gt;Driver&lt;/em&gt; influencing the response variable.&lt;/li&gt;
&lt;li&gt;$t$ is the time of any given value of the response $p$.&lt;/li&gt;
&lt;li&gt;$t-1$ is the lag 1.&lt;/li&gt;
&lt;li&gt;$p_{t-1} +&amp;hellip;+ p_{t-n}$ represents the endogenous component of
ecological memory.&lt;/li&gt;
&lt;li&gt;$d_{t-1} +&amp;hellip;+ d_{t-n}$ represents the exogenous component of
ecological memory.&lt;/li&gt;
&lt;li&gt;$d_{t}$ represents the concurrent effect of the driver over the
response.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Random Forest returns an importance score for each model term, and the
functions in &lt;em&gt;memoria&lt;/em&gt; let the user to plot the importance scores across
time lags for each ecological memory components, and to compute
different features of each memory component (length, strength, and
dominance).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;output.png&#34; alt=&#34;Outputs produced by memoria from the analysis of a multivariate time series&#34;&gt;&lt;/p&gt;
&lt;p&gt;The 
&lt;a href=&#34;https://github.com/BlasBenito/memoria&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub page&lt;/a&gt; of the package features complete examples on how to use the package. The 
&lt;a href=&#34;https://onlinelibrary.wiley.com/doi/full/10.1111/ecog.04772&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;paper published in the Ecography journal&lt;/a&gt; describes ecological memory concepts and the method based on Random Forest used to assess ecological memory components. The code used to generate the supplementary materials can be found in 
&lt;a href=&#34;https://github.com/BlasBenito/EcologicalMemory&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; and 
&lt;a href=&#34;https://zenodo.org/record/3236128#.X941v9Yo-1c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Zenodo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you ever use the package, please, cite it as:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Benito, B.M., Gil‐Romera, G. and Birks, H.J.B. (2020), Ecological memory at millennial time‐scales: the importance of data constraints, species longevity and niche features. Ecography, 43: 1-10. &lt;a href=&#34;https://doi.org/10.1111/ecog.04772&#34;&gt;https://doi.org/10.1111/ecog.04772&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>R package &#34;spatialRF&#34;</title>
      <link>/project/spatialrf/</link>
      <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
      <guid>/project/spatialrf/</guid>
      <description>
&lt;script src=&#34;/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/anchor-sections/anchor-sections.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/anchor-sections/anchor-sections.js&#34;&gt;&lt;/script&gt;


&lt;!---
[![R-CMD-check](https://github.com/BlasBenito/spatialRF/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/BlasBenito/spatialRF/actions/workflows/R-CMD-check.yaml)
--&gt;
&lt;!-- badges: start --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/blasbenito/spatialRF&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/devel%20version-1.0.7-blue.svg&#34; alt=&#34;Devel-version&#34; /&gt;&lt;/a&gt;&lt;a href=&#34;https://lifecycle.r-lib.org/articles/stages.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/lifecycle-experimental-orange.svg&#34; alt=&#34;lifecycle&#34; /&gt;&lt;/a&gt;&lt;a href=&#34;https://github.com/blasbenito/spatialRF&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/CRAN-not_published_yet-red&#34; alt=&#34;CRAN&#34; /&gt;&lt;/a&gt;&lt;a href=&#34;https://www.gnu.org/licenses/gpl-3.0.en.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-GPL--3-blue.svg&#34; alt=&#34;License&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;!-- badges: end --&gt;
&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The package &lt;strong&gt;spatialRF&lt;/strong&gt; facilitates fitting spatial regression models on regular or irregular data with Random Forest by generating &lt;em&gt;spatial predictors&lt;/em&gt; that allow the model to take into account the spatial structure of the training data. The end goal is minimizing the spatial autocorrelation of the model residuals as much as possible.&lt;/p&gt;
&lt;p&gt;Two main methods to generate &lt;em&gt;spatial predictors&lt;/em&gt; from the distance matrix of the data points are implemented in the package:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Moran’s Eigenvector Maps &lt;a href=&#34;https://www.sciencedirect.com/science/article/abs/pii/S0304380006000925&#34;&gt;(Dray, Legendre, and Peres-Neto 2006)&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Distance matrix columns as explanatory variables &lt;a href=&#34;https://peerj.com/articles/5518/&#34;&gt;(Hengl et al. 2018)&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The package is designed to minimize the amount of code required to fit a spatial model from a training dataset, the names of the response and the predictors, and a distance matrix, as the example below shows.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spatial.model &amp;lt;- rf_spatial(
  data = your_dataframe,
  dependent.variable.name = &amp;quot;your_response_variable&amp;quot;,
  predictor.variable.names = c(&amp;quot;predictor1&amp;quot;, &amp;quot;predictor2&amp;quot;, ..., &amp;quot;predictorN&amp;quot;),
  distance.matrix = your_distance_matrix
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The package, that uses the &lt;code&gt;ranger&lt;/code&gt; package under the hood &lt;a href=&#34;https://arxiv.org/abs/1508.04409&#34;&gt;(Wright and Ziegler 2017)&lt;/a&gt;, also provides tools to identify potentially interesting variable interactions, tune random forest hyperparameters, assess model performance on spatially independent data folds, and examine the resulting models via importance plots, response curves, and response surfaces.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;development&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Development&lt;/h1&gt;
&lt;p&gt;This package is reaching its final form, and big changes are not expected at this stage. However, it has many functions, and even though all them have been tested, only one dataset has been used for those tests. You will find bugs, and something will go wrong almost surely. If you have time to report bugs, please, do so in any of the following ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Open a new issue in the &lt;a href=&#34;https://github.com/BlasBenito/spatialRF/issues&#34;&gt;Issues GitHub page of the package&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Send me an email explaining the issue and the error messages with enough detail at blasbenito at gmail dot com.&lt;/li&gt;
&lt;li&gt;Send a direct message to &lt;a href=&#34;https://twitter.com/blasbenito&#34;&gt;my twitter account&lt;/a&gt; explaining the issue.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will do my best to solve any issues ASAP!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;applications&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Applications&lt;/h1&gt;
&lt;p&gt;The goal of &lt;code&gt;spatialRF&lt;/code&gt; is to help fitting &lt;em&gt;explanatory spatial regression&lt;/em&gt;, where the target is to understand how a set of predictors and the spatial structure of the data influences response variable. Therefore, the spatial analyses implemented in the package can be applied to any spatial dataset, regular or irregular, with a sample size between ~100 and ~5000 cases (the higher end will depend on the RAM memory available), a quantitative or binary (values 0 and 1) response variable, and a more or less large set of predictive variables.&lt;/p&gt;
&lt;p&gt;All functions but &lt;code&gt;rf_spatial()&lt;/code&gt; work with non-spatial data as well if the arguments &lt;code&gt;distance.matrix&lt;/code&gt; and &lt;code&gt;distance.thresholds&lt;/code&gt; are ignored. In such case, the number of cases is no longer limited by the size of the distance matrix, and models can be trained with hundreds of thousands of rows.&lt;/p&gt;
&lt;p&gt;However, &lt;strong&gt;when the focus is on fitting spatial models&lt;/strong&gt;, and due to the nature of the &lt;em&gt;spatial predictors&lt;/em&gt; used to represent the spatial structure of the training data, &lt;strong&gt;there are many things this package cannot do&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Predict model results over raster data.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Predict a model result over another region with a different spatial structure.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Work with “big data”, whatever that means.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Imputation or extrapolation (it can be done, but models based on spatial predictors are hardly transferable).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Take temporal autocorrelation into account (but this is something that might be implemented later on).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If after considering these limitations you are still interested, follow me, I will show you how it works.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;install&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Install&lt;/h1&gt;
&lt;p&gt;The package is not yet in the CRAN repositories, so at the moment it must be installed from GitHub as follows.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;remotes::install_github(
  repo = &amp;quot;blasbenito/spatialRF&amp;quot;, 
  ref = &amp;quot;main&amp;quot;,
  force = TRUE,
  quiet = TRUE
  )
library(spatialRF)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a few other libraries that will be useful during this tutorial.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(kableExtra)
library(rnaturalearth)
library(rnaturalearthdata)
library(tidyverse)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;data-requirements&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Data requirements&lt;/h1&gt;
&lt;p&gt;The data required to fit random forest models with &lt;code&gt;spatialRF&lt;/code&gt; must fulfill several conditions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The input format is data.frame&lt;/strong&gt;. At the moment, tibbles are not fully supported.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The number of rows must be somewhere between 100 and ~5000&lt;/strong&gt;, but that will depend on the RAM available in your system. However, this limitation only affects spatial analyses performed with &lt;code&gt;rf_spatial()&lt;/code&gt;, while all other modeling and plotting functions should work without a distance matrix (if they don’t tell me, that’d be a bug!), and therefore analyses in large datasets can still be done with the package.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The number of predictors should be larger than 3&lt;/strong&gt;, fitting a Random Forest model is moot otherwise.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Factors in the response or the predictors are not explicitly supported in the package&lt;/strong&gt;, they may work, or they won’t, but in any case, I designed this package for quantitative data alone. However, binary data with values 0 and 1 in the response variable are supported.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Must be free of &lt;code&gt;NA&lt;/code&gt;&lt;/strong&gt;. You can check if there are NA records with &lt;code&gt;sum(apply(df, 2, is.na))&lt;/code&gt;. If the result is larger than 0, then just execute &lt;code&gt;df &amp;lt;- na.omit(df)&lt;/code&gt; to remove rows with empty cells.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Columns cannot have zero variance&lt;/strong&gt;. This condition can be checked with &lt;code&gt;apply(df, 2, var) == 0&lt;/code&gt;. Columns yielding TRUE should be removed.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Columns must not yield &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Inf&lt;/code&gt; when scaled&lt;/strong&gt;. You can check each condition with &lt;code&gt;sum(apply(scale(df), 2, is.nan))&lt;/code&gt; and &lt;code&gt;sum(apply(scale(df), 2, is.infinite))&lt;/code&gt;. If higher than 0, you can find what columns are giving issues with &lt;code&gt;sapply(as.data.frame(scale(df)), function(x)any(is.nan(x)))&lt;/code&gt; and &lt;code&gt;sapply(as.data.frame(scale(df)), function(x)any(is.infinite(x)))&lt;/code&gt;. Any column yielding &lt;code&gt;TRUE&lt;/code&gt; will generate issues while trying to fit models with &lt;code&gt;spatialRF&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;example-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Example data&lt;/h1&gt;
&lt;p&gt;The package includes an example dataset that fulfills the conditions mentioned above, named &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plant_richness_df.html&#34;&gt;&lt;code&gt;plant_richness_df&lt;/code&gt;&lt;/a&gt;. It is a data frame with plant species richness and predictors for 227 ecoregions in the Americas, and a distance matrix among the ecoregion edges named, well, &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/distance_matrix.html&#34;&gt;&lt;code&gt;distance_matrix&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(plant_richness_df)
data(distance_matrix)

#names of the response variable and the predictors
dependent.variable.name &amp;lt;- &amp;quot;richness_species_vascular&amp;quot;
predictor.variable.names &amp;lt;- colnames(plant_richness_df)[5:21]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The response variable of &lt;code&gt;plant_richness_df&lt;/code&gt; is “richness_species_vascular”, with the total count of vascular plant species found on each ecoregion. The figure below shows the centroids of each ecoregion along with their associated value of the response variable.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;figure1.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The predictors (columns 5 to 21) represent diverse factors that may influence plant richness such as sampling bias, the area of the ecoregion, climatic variables, human presence and impact, topography, geographical fragmentation, and features of the neighbors of each ecoregion. The figure below shows the scatterplots of the response variable (y axis) against each predictor (x axis).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;figure2.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;plot_training_df_moran()&lt;/code&gt; helps to check the spatial autocorrelation of the response variable and the predictors.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;figure3.png&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;finding-promising-variable-interactions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Finding promising variable interactions&lt;/h1&gt;
&lt;p&gt;Random Forests already takes into account variable interactions of the form “variable &lt;code&gt;a&lt;/code&gt; becomes important when &lt;code&gt;b&lt;/code&gt; is higher than x”. However, Random Forest can also take advantage of variable interactions of the form &lt;code&gt;a * b&lt;/code&gt;, as they are commonly defined in regression models.&lt;/p&gt;
&lt;p&gt;The function &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rf_interactions.html&#34;&gt;&lt;code&gt;rf_interactions()&lt;/code&gt;&lt;/a&gt; tests all possible interactions among predictors by using each one of them in a separate model, and suggesting the ones with the higher potential contribution to the model’s R squared and the higher relative importance (presented as a percentage of the maximum importance of a variable in the model).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;interactions &amp;lt;- rf_interactions(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names
  )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Testing 10 candidate interactions.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2 potential interactions identified.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       ┌─────────────────────────┬───────────────────────┬────────────────┐
##       │ Interaction             │ Importance (% of max) │ R2 improvement │
##       ├─────────────────────────┼───────────────────────┼────────────────┤
##       │ human_population_X_bias │                 100.0 │          0.002 │
##       │ _area_km2               │                       │                │
##       ├─────────────────────────┼───────────────────────┼────────────────┤
##       │ climate_bio1_average_X_ │                  81.7 │          0     │
##       │ bias_area_km2           │                       │                │
##       └─────────────────────────┴───────────────────────┴────────────────┘&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;figure4.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Here &lt;code&gt;rf_interactions()&lt;/code&gt; suggests several candidate interactions ordered by their impact on the model. The function cannot say whether an interaction &lt;em&gt;makes sense&lt;/em&gt;, and it is up to the user to choose wisely whether to select an interaction or not.&lt;/p&gt;
&lt;p&gt;For the sake of the example, I will choose &lt;code&gt;climate_bio1_average_X_bias_area_km2&lt;/code&gt;, hypothesizing that ecoregions with higher area (bias_area_km2) and energy (represented by the annual temperature, climate_bio1_average) will have more species of vascular plants (this is just an example, many other rationales are possible when choosing between candidate interactions). The data required to add the interaction to the training data is in the output of &lt;code&gt;rf_interactions()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#adding interaction column to the training data
plant_richness_df[, &amp;quot;climate_bio1_average_X_bias_area_km2&amp;quot;] &amp;lt;- interactions$columns[, &amp;quot;climate_bio1_average_X_bias_area_km2&amp;quot;]

#adding interaction name to predictor.variable.names
predictor.variable.names &amp;lt;- c(predictor.variable.names, &amp;quot;climate_bio1_average_X_bias_area_km2&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;reducing-multicollinearity-in-the-predictors&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Reducing multicollinearity in the predictors&lt;/h1&gt;
&lt;p&gt;The functions &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/auto_cor.html&#34;&gt;&lt;code&gt;auto_cor()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/auto_vif.html&#34;&gt;&lt;code&gt;auto_vif()&lt;/code&gt;&lt;/a&gt; help reduce redundancy in the predictors by using different criteria (bivariate R squared vs. &lt;a href=&#34;https://www.statisticshowto.com/variance-inflation-factor/&#34;&gt;variance inflation factor&lt;/a&gt;), while allowing the user to define an &lt;em&gt;order of preference&lt;/em&gt;, which can be based either on domain expertise or on a quantitative assessment. The preference order is defined as a character vector in the &lt;code&gt;preference.order&lt;/code&gt; argument of both functions, and does not need to include the names of all predictors, but just the ones the user would like to keep in the analysis.&lt;/p&gt;
&lt;p&gt;In the example below I give preference to the interaction suggested by &lt;code&gt;rf_interactions()&lt;/code&gt; over it’s two components, and prioritize climate over other types of predictors (any other choice would be valid, it just depends on the scope of the study). These rules are applied to both &lt;code&gt;auto_cor()&lt;/code&gt; and &lt;code&gt;auto_vif()&lt;/code&gt;, that are executed sequentially by using the &lt;code&gt;%&amp;gt;%&lt;/code&gt; pipe from the &lt;a href=&#34;https://magrittr.tidyverse.org/&#34;&gt;magrittr&lt;/a&gt; package.&lt;/p&gt;
&lt;p&gt;Notice that I have set &lt;code&gt;cor.threshold&lt;/code&gt; and &lt;code&gt;vif.threshold&lt;/code&gt; to low values because the predictors in &lt;code&gt;plant_richness_df&lt;/code&gt; already have little multicollinearity,. The default values (&lt;code&gt;cor.threshold = 0.75&lt;/code&gt; and &lt;code&gt;vif.threshold = 5&lt;/code&gt;) should work well when combined together for any other set of predictors.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;preference.order &amp;lt;- c(
    &amp;quot;climate_bio1_average_X_bias_area_km2&amp;quot;,
    &amp;quot;climate_aridity_index_average&amp;quot;,
    &amp;quot;climate_hypervolume&amp;quot;,
    &amp;quot;climate_bio1_average&amp;quot;,
    &amp;quot;climate_bio15_minimum&amp;quot;,
    &amp;quot;bias_area_km2&amp;quot;
  )

predictor.variable.names &amp;lt;- auto_cor(
  x = plant_richness_df[, predictor.variable.names],
  cor.threshold = 0.6,
  preference.order = preference.order
) %&amp;gt;% 
  auto_vif(
    vif.threshold = 2.5,
    preference.order = preference.order
  )&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [auto_cor()]: Removed variables: bias_area_km2, human_footprint_average&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [auto_vif()]: Removed variables: human_population&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of &lt;code&gt;auto_cor()&lt;/code&gt; or &lt;code&gt;auto_vif()&lt;/code&gt; is of the class “variable_selection”, that can be used as input for the argument &lt;code&gt;predictor.variable.names&lt;/code&gt; of any modeling function within the package. An example is shown in the next section.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;fitting-a-non-spatial-random-forest-model&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Fitting a non-spatial Random Forest model&lt;/h1&gt;
&lt;p&gt;To fit basic Random Forest models &lt;code&gt;spatialRF&lt;/code&gt; provides the &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rf.html&#34;&gt;&lt;code&gt;rf()&lt;/code&gt;&lt;/a&gt; function. It takes the training data, the names of the response and the predictors, and optionally (to assess the spatial autocorrelation of the residuals), the distance matrix, and a vector of distance thresholds (in the same units as the distances in &lt;strong&gt;distance_matrix&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;These distance thresholds are the neighborhoods at which the model will check the spatial autocorrelation of the residuals. Their values may depend on the spatial scale of the data, and the ecological system under study.&lt;/p&gt;
&lt;p&gt;Notice that here I plug the object &lt;code&gt;predictor.variable.names&lt;/code&gt;, output of &lt;code&gt;auto_cor()&lt;/code&gt; and &lt;code&gt;auto_vif()&lt;/code&gt;, directly into the &lt;code&gt;predictor.variable.names&lt;/code&gt; argument.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;model.non.spatial &amp;lt;- rf(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance_matrix,
  distance.thresholds = c(0, 1500, 3000),
  seed = 100, #for reproducibility
  verbose = FALSE
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The model output can be printed or plotted with a plethora of functions such as &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/print.html&#34;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/print_importance.html&#34;&gt;&lt;code&gt;print_importance()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/print_performance.html&#34;&gt;&lt;code&gt;print_performance()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plot_importance.html&#34;&gt;&lt;code&gt;plot_importance()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/print_moran.html&#34;&gt;&lt;code&gt;print_moran()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plot_moran.html&#34;&gt;&lt;code&gt;plot_moran()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plot_response_curves.html&#34;&gt;&lt;code&gt;plot_response_curves()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plot_response_surfaces.html&#34;&gt;&lt;code&gt;plot_response_surfaces)&lt;/code&gt;&lt;/a&gt;, among many others.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot_response_curves(model.non.spatial)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;figure5.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In the response curves above, the other predictors are set to their quantiles 0.1, 0.5, and 0.8, but the user can change this behavior by modifying the values of the &lt;code&gt;quantiles&lt;/code&gt; argument.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot_response_surfaces(
  x = model.non.spatial,
  a = &amp;quot;climate_bio1_average&amp;quot;,
  b = &amp;quot;neighbors_count&amp;quot;
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;figure6.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In this response surface, the predictors that are not shown are set to their medians (but other quantiles are possible).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot_importance(model.non.spatial, verbose = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;figure7.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Predicting onto new data&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Models fitted with &lt;code&gt;rf()&lt;/code&gt; and other &lt;code&gt;rf_X()&lt;/code&gt; functions within the package can be predicted onto new data just as it is done with &lt;code&gt;ranger()&lt;/code&gt; models:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;predicted &amp;lt;- stats::predict(
  object = model.non.spatial,
  data = plant_richness_df,
  type = &amp;quot;response&amp;quot;
  )$predictions&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Repeating a model execution&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Random Forest is an stochastic algorithm that yields slightly different results on each run unless a random seed is set. This particularity has implications for the interpretation of variable importance scores. For example, in the plot above, the difference in importance between the predictors &lt;code&gt;climate_hypervolume&lt;/code&gt; and &lt;code&gt;climate_bio1_average_X_bias_area_km2&lt;/code&gt; could be just the result of chance. The function &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rf_repeat.html&#34;&gt;&lt;code&gt;rf_repeat()&lt;/code&gt;&lt;/a&gt; repeats a model execution and yields the distribution of importance scores of the predictors across executions.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;model.non.spatial.repeat &amp;lt;- rf_repeat(
  model = model.non.spatial, 
  repetitions = 30,
  verbose = FALSE
)

plot_importance(model.non.spatial.repeat, verbose = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;figure8.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;After 30 model repetitions it is clear that the difference in importance between &lt;code&gt;climate_hypervolume&lt;/code&gt; and &lt;code&gt;climate_bio1_average_X_bias_area_km2&lt;/code&gt; is not the result of chance.&lt;/p&gt;
&lt;p&gt;The response curves of models fitted with &lt;code&gt;rf_repeat()&lt;/code&gt; can be plotted with &lt;code&gt;plot_response_curves()&lt;/code&gt; as well. The median prediction is shown with a thicker line.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot_response_curves(
  model.non.spatial.repeat, 
  quantiles = 0.5
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;figure9.png&#34; /&gt;
The function &lt;code&gt;get_response_curves()&lt;/code&gt; returns a data frame with the data required to make custom plots of the response curves.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot.df &amp;lt;- get_response_curves(model.non.spatial.repeat)&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;right&#34;&gt;response&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;predictor&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;quantile&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;model&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;predictor.name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;response.name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;1347.937&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-183.8091&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;climate_bio1_average&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;richness_species_vascular&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;1347.937&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-181.5008&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;climate_bio1_average&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;richness_species_vascular&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;1347.937&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-179.1924&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;climate_bio1_average&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;richness_species_vascular&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;1347.937&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-176.8841&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;climate_bio1_average&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;richness_species_vascular&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;1347.937&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-174.5758&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;climate_bio1_average&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;richness_species_vascular&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;1347.937&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-172.2675&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;climate_bio1_average&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;richness_species_vascular&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;1347.937&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-169.9592&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;climate_bio1_average&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;richness_species_vascular&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;1347.937&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-167.6509&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;climate_bio1_average&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;richness_species_vascular&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;1347.937&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-165.3426&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;climate_bio1_average&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;richness_species_vascular&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;1347.937&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-163.0343&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;climate_bio1_average&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;richness_species_vascular&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div id=&#34;tuning-random-forest-hyperparameters&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Tuning Random Forest hyperparameters&lt;/h1&gt;
&lt;p&gt;The model fitted above was based on the default hyperparameter values provided by &lt;code&gt;ranger()&lt;/code&gt;, and those might not be the most adequate ones for a given dataset. The function &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rf_tuning.html&#34;&gt;&lt;code&gt;rf_tuning()&lt;/code&gt;&lt;/a&gt; helps the user to choose sensible values for three Random Forest hyperparameters that are critical to model performance:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;num.trees&lt;/code&gt;: number of regression trees in the forest.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mtry&lt;/code&gt;: number of variables to choose from on each tree split.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min.node.size&lt;/code&gt;: minimum number of cases on a terminal node.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Model tuning can be done on out-of-bag (&lt;code&gt;method = &#34;oob&#34;&lt;/code&gt;) or spatial cross-validation (&lt;code&gt;method = &#34;spatial.cv&#34;&lt;/code&gt;) R squared values. The example below shows the out-of-bag approach because I will explain spatial cross-validation with &lt;code&gt;rf_evaluate()&lt;/code&gt; later in this document.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;model.non.spatial.tuned &amp;lt;- rf_tuning(
  model = model.non.spatial,
  method = &amp;quot;spatial.cv&amp;quot;,
  xy = plant_richness_df[, c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;)],
  repetitions = 30,
  num.trees = c(500, 1000),
  mtry = seq(
    2, 
    14, #equal or lower than the number of predictors
    by = 3
    ),
  min.node.size = c(5, 10, 20)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Exploring 30 combinations of hyperparameters.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Best hyperparameters:&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   - num.trees:     1000&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   - mtry:          14&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   - min.node.size: 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R squared gain: 0.029&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;figure10.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;rf_tuning()&lt;/code&gt; returns a model fitted with the same data as the original model, but using the best hyperparameters found during tuning. Model tuning has helped to a very small improvement in performance measures (+ 0.029 R squared), so from here, we can keep working with &lt;code&gt;model.non.spatial.tuned&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;fitting-a-spatial-model&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Fitting a spatial model&lt;/h1&gt;
&lt;p&gt;The spatial autocorrelation of the residuals of &lt;code&gt;model.non.spatial&lt;/code&gt;, measured with &lt;a href=&#34;https://en.wikipedia.org/wiki/Moran%27s_I&#34;&gt;Moran’s I&lt;/a&gt;, can be plotted with &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plot_moran.html&#34;&gt;&lt;code&gt;plot_moran()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot_moran(model.non.spatial.tuned, verbose = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;figure11.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;According to the plot, the spatial autocorrelation of the residuals is highly positive for a neighborhood of 0 km, while it becomes non-significant (p-value &amp;gt; 0.05, whatever that means) at 1500 and 3000 km. To reduce the spatial autocorrelation of the residuals as much as possible, the non-spatial tuned model fitted above can be converted into a spatial model easily with &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rf_spatial.html&#34;&gt;&lt;code&gt;rf_spatial()&lt;/code&gt;&lt;/a&gt;, that by default uses the Moran’s Eigenvector Maps method.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;model.spatial &amp;lt;- rf_spatial(
  model = model.non.spatial.tuned,
  method = &amp;quot;mem.moran.sequential&amp;quot;, #default method
  verbose = FALSE,
  seed = 100
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The plot below shows the Moran’s I of the residuals of the spatial model. It shows that &lt;code&gt;rf_spatial()&lt;/code&gt; has managed to remove the spatial autocorrelation (p-values of the Moran’s I estimates for each neighborhood distance are higher than 0.05) of the model residuals for every neighborhood distance.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot_moran(model.spatial, verbose = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;figure12.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;When comparing the variable importance plots of both models, we can see that the spatial model has an additional set of dots under the name “spatial_predictors”, and that the maximum importance of a few of these spatial predictors matches the importance of the most relevant non-spatial predictors.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p1 &amp;lt;- plot_importance(
  model.non.spatial, 
  verbose = FALSE) + 
  ggplot2::ggtitle(&amp;quot;Non-spatial model&amp;quot;) 

p2 &amp;lt;- plot_importance(
  model.spatial,
  verbose = FALSE) + 
  ggplot2::ggtitle(&amp;quot;Spatial model&amp;quot;)

p1 | p2 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;figure13.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;A few of the ten most important variables in &lt;code&gt;model.spatial&lt;/code&gt; are spatial predictors.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;variable&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;importance&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;climate_bio1_average_X_bias_area_km2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.151&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;spatial_predictor_0_2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.147&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;climate_hypervolume&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.140&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;climate_bio1_average&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.132&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;bias_species_per_record&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.080&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;spatial_predictor_0_1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.064&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;spatial_predictor_3000_1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.057&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;spatial_predictor_0_6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.053&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;spatial_predictor_0_5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.045&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;human_population_density&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.041&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Spatial predictors are named &lt;code&gt;spatial_predictor_X_Y&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is the neighborhood distance at which the predictor has been generated, and &lt;code&gt;Y&lt;/code&gt; is the index of the predictor.&lt;/p&gt;
&lt;p&gt;Spatial predictors, as shown below, are smooth surfaces representing neighborhood among records at different spatial scales.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;figure14.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The spatial predictors in the spatial model have been generated using the method “mem.moran.sequential” (function’s default), that mimics the Moran’s Eigenvector Maps method described in &lt;a href=&#34;https://www.sciencedirect.com/science/article/abs/pii/S0304380006000925&#34;&gt;(Dray, Legendre, and Peres-Neto 2006)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In brief, the method consist on transforming the distance matrix into a double-centered matrix of normalized weights, to then compute the positive eigenvectors of the weights matrix (a.k.a, Moran’s Eigenvector Maps, or MEMs).&lt;/p&gt;
&lt;p&gt;The MEMs are included in the model one by one in the order of their Moran’s I, and the subset of MEMs maximizing the model’s R squared and minimizing the Moran’s I of the residuals and the number of MEMs added to the model are selected, as shown in the optimization plot below (dots linked by lines represent the selected spatial predictors). The selection procedure is performed by the function &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/select_spatial_predictors_sequential.html&#34;&gt;&lt;code&gt;select_spatial_predictors_sequential()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;figure15.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tuning spatial models&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spatial models fitted with &lt;code&gt;rf_spatial()&lt;/code&gt; can be tuned as well with &lt;code&gt;rf_tuning()&lt;/code&gt;. However, tuning may in some cases increase the spatial autocorrelation of the model residuals. In that case, the function will return a message explaining the situation, and the original model without any sort of tuning applied&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;model.spatial.tuned &amp;lt;- rf_tuning(
  model = model.spatial,
  method = &amp;quot;spatial.cv&amp;quot;,
  xy = plant_richness_df[, c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;)],
  repetitions = 30,
  num.trees = c(500, 1000),
  mtry = seq(
    2,
    length(model.spatial$ranger.arguments$predictor.variable.names),
    by = 9),
  min.node.size = c(5, 20)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Exploring 24 combinations of hyperparameters.&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Best hyperparameters:&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   - num.trees:     1000&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   - mtry:          47&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   - min.node.size: 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## R squared gain: 0.016&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;figure16.png&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;assessing-model-performance-on-spatially-independent-folds&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Assessing model performance on spatially independent folds&lt;/h1&gt;
&lt;p&gt;The function &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rf_evaluate.html&#34;&gt;&lt;code&gt;rf_evaluate()&lt;/code&gt;&lt;/a&gt; separates the training data into a number of spatially independent training and testing folds, fits a model on each training fold, predicts over each testing fold, and computes performance measures, to finally aggregate them across model repetitions. Let’s see how it works.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;model.spatial.tuned &amp;lt;- rf_evaluate(
  model = model.spatial.tuned,
  xy = plant_richness_df[, c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;)], #data coordinates
  repetitions = 30,                      #number of folds
  training.fraction = 0.8,               #training data fraction
  metrics = c(&amp;quot;r.squared&amp;quot;, &amp;quot;rmse&amp;quot;),
  verbose = FALSE
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function generates a new slot in the model named “evaluation” with several objects that summarize the spatial cross-validation results.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(model.spatial.tuned$evaluation)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;metrics&amp;quot;           &amp;quot;training.fraction&amp;quot; &amp;quot;spatial.folds&amp;quot;    
## [4] &amp;quot;per.fold&amp;quot;          &amp;quot;per.fold.long&amp;quot;     &amp;quot;per.model&amp;quot;        
## [7] &amp;quot;aggregated&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The slot “spatial.folds”, produced by &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/make_spatial_folds.html&#34;&gt;&lt;code&gt;make_spatial_folds()&lt;/code&gt;&lt;/a&gt;, contains the indices of the training and testing cases for each cross-validation repetition. The maps below show two sets of training and testing spatial folds.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;figure17.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The functions &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plot_evaluation.html&#34;&gt;&lt;code&gt;plot_evaluation()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/print_evaluation.html&#34;&gt;&lt;code&gt;print_evaluation()&lt;/code&gt;&lt;/a&gt; allow to check the evaluation results as a plot or as a table.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print_evaluation(model.spatial.tuned)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Spatial evaluation 
##   - Training fraction:             0.8
##   - Spatial folds:                 25
## 
##     Metric     Mean Standard deviation  Minimum  Maximum
##  r.squared    0.250              0.159    0.080    0.601
##       rmse 3223.499            810.886 2285.215 4748.118&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The low R squared yielded by the model evaluation shows that the spatial model is hard to transfer outside of the training space. Models based on a spatial structure like the ones fitted with &lt;code&gt;rf_spatial()&lt;/code&gt; do not work well when transferred to a different place (that is what &lt;code&gt;rf_compare()&lt;/code&gt; does), because spatial structures are not transferable when the data is irregularly distributed, as it is the case with &lt;code&gt;plant_richness_df&lt;/code&gt;. The comparison below shows how non-spatial models may show better (not bad, not great) evaluation scores on independent spatial folds.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;comparing-several-models&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Comparing several models&lt;/h1&gt;
&lt;p&gt;The function &lt;code&gt;rf_evaluate()&lt;/code&gt; only assesses the predictive performance on unseen data of one model at a time. If the goal is to compare two models, &lt;code&gt;rf_evaluate()&lt;/code&gt; can be indeed ran twice, but &lt;code&gt;spatialRF&lt;/code&gt; offers a more convenient option named &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rf_compare.html&#34;&gt;&lt;code&gt;rf_compare()&lt;/code&gt;&lt;/a&gt;. It takes as input a named list with as many models as the user needs to compare.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;comparison &amp;lt;- rf_compare(
  models = list(
    `Non-spatial` = model.non.spatial,
    `Non-spatial tuned` = model.non.spatial.tuned,
    `Spatial` = model.spatial,
    `Spatial tuned` = model.spatial.tuned
  ),
  xy = plant_richness_df[, c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;)],
  repetitions = 30,
  training.fraction = 0.8,
  metrics = c(&amp;quot;r.squared&amp;quot;, &amp;quot;rmse&amp;quot;),
  notch = TRUE
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;figure18.png&#34; /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Model&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Metric&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Mean&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Non-spatial&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;r.squared&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.336&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Non-spatial tuned&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;r.squared&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.412&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Spatial&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;r.squared&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.167&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Spatial tuned&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;r.squared&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.217&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Non-spatial&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;rmse&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2817.225&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Non-spatial tuned&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;rmse&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2329.933&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Spatial&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;rmse&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3086.170&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Spatial tuned&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;rmse&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2930.469&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div id=&#34;generating-spatial-predictors-for-other-models&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Generating spatial predictors for other models&lt;/h1&gt;
&lt;p&gt;You might not love Random Forest, but &lt;code&gt;spatialRF&lt;/code&gt; loves you, and as such, it gives you tools to generate spatial predictors for other models anyway.&lt;/p&gt;
&lt;p&gt;The first step requires generating Moran’s Eigenvector Maps (MEMs) from the distance matrix. Here there are two options, computing MEMs for a single neighborhood distance with &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/mem.html&#34;&gt;&lt;code&gt;mem()&lt;/code&gt;&lt;/a&gt;, and computing MEMs for several neighborhood distances at once with &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/mem_multithreshold.html&#34;&gt;&lt;code&gt;mem_multithreshold()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#single distance (0km by default)
mems &amp;lt;- mem(x = distance_matrix)

#several distances
mems &amp;lt;- mem_multithreshold(
  x = distance_matrix,
  distance.thresholds = c(0, 1000, 2000)
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In either case the result is a data frame with Moran’s Eigenvector Maps (“just” the positive eigenvectors of the double-centered distance matrix).&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;right&#34;&gt;spatial_predictor_0_1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;spatial_predictor_0_2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;spatial_predictor_0_3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;spatial_predictor_0_4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;0.0259217&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0052203&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0416969&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0363324&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;0.0996679&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0539713&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.1324480&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.3826928&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;0.0010477&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0143046&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0443602&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0031386&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;0.0165695&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0047991&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0307457&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0005170&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;0.0225761&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0019595&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0230368&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0524239&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;0.0155252&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0023742&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0197953&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0338956&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;0.0229197&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0039860&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0312561&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0416697&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;-0.2436009&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.1155295&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0791452&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0189996&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;right&#34;&gt;0.0150725&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0158684&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.1010284&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0095590&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;right&#34;&gt;-0.1187381&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0471879&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0359881&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0065211&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;But not all MEMs are made equal, and you will need to rank them by their Moran’s I. The function &lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rank_spatial_predictors.html&#34;&gt;&lt;code&gt;rank_spatial_predictors()&lt;/code&gt;&lt;/a&gt; will help you do so.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mem.rank &amp;lt;- rank_spatial_predictors(
  distance.matrix = distance_matrix,
  spatial.predictors.df = mems
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of &lt;code&gt;rank_spatial_predictors()&lt;/code&gt; is a list with three slots: “method”, a character string with the name of the ranking method; “criteria”, an ordered data frame with the criteria used to rank the spatial predictors; and “ranking”, a character vector with the names of the spatial predictors in the order of their ranking (it is just the first column of the “criteria” data frame). We can use this “ranking” object to reorder or &lt;code&gt;mems&lt;/code&gt; data frame.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mems &amp;lt;- mems[, mem.rank$ranking]

#also:
#mems &amp;lt;- mem.rank$spatial.predictors.df&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From here, spatial predictors can be included in any model one by one, in the order of the ranking, until the spatial autocorrelation of the residuals is gone, or our model gets totally defaced. A little example with a linear model follows.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#model definition
predictors &amp;lt;- c(
  &amp;quot;climate_aridity_index_average &amp;quot;,
  &amp;quot;climate_bio1_average&amp;quot;,
  &amp;quot;bias_species_per_record&amp;quot;,
  &amp;quot;human_population_density&amp;quot;,
  &amp;quot;topography_elevation_average&amp;quot;,
  &amp;quot;fragmentation_division&amp;quot;
)
model.formula &amp;lt;- as.formula(
  paste(
    dependent.variable.name,
    &amp;quot; ~ &amp;quot;,
    paste(
      predictors,
      collapse = &amp;quot; + &amp;quot;
    )
  )
)

#scaling the data
model.data &amp;lt;- scale(plant_richness_df) %&amp;gt;% 
  as.data.frame()

#fitting the model
m &amp;lt;- lm(model.formula, data = plant_richness_df)

#Moran&amp;#39;s I test of the residuals
moran.test &amp;lt;- moran(
  x = residuals(m),
  distance.matrix = distance_matrix,
)
moran.test&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   moran.i p.value               interpretation
## 1    0.21       0 Positive spatial correlation&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;According to the Moran’s I test, the model residuals show spatial autocorrelation. Let’s introduce MEMs one by one until the problem is solved.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#add mems to the data and applies scale()
model.data &amp;lt;- data.frame(
  plant_richness_df,
  mems
) %&amp;gt;%
  scale() %&amp;gt;%
  as.data.frame()

#initialize predictors.i
predictors.i &amp;lt;- predictors

#iterating through MEMs
for(mem.i in colnames(mems)){
  
  #add mem name to model definintion
  predictors.i &amp;lt;- c(predictors.i, mem.i)
  
  #generate model formula with the new spatial predictor
  model.formula.i &amp;lt;- as.formula(
    paste(
      dependent.variable.name,
      &amp;quot; ~ &amp;quot;,
      paste(
        predictors.i,
        collapse = &amp;quot; + &amp;quot;
      )
    )
  )
  
  #fit model
  m.i &amp;lt;- lm(model.formula.i, data = model.data)
  
  #Moran&amp;#39;s I test
  moran.test.i &amp;lt;- moran(
    x = residuals(m.i),
    distance.matrix = distance_matrix,
  )
  
  #stop if no autocorrelation
  if(moran.test.i$interpretation != &amp;quot;Positive spatial correlation&amp;quot;){
    break
  }
  
}#end of loop&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can compare the model without spatial predictors &lt;code&gt;m&lt;/code&gt; and the model with spatial predictors &lt;code&gt;m.i&lt;/code&gt;.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Model&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Predictors&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;R_squared&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;AIC&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;BIC&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Moran.I&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Non-spatial&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.38&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4238&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4266&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.21&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Spatial&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.50&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;530&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;608&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.06&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;According to the model comparison, it can be concluded that the addition of spatial predictors, in spite of the increase in complexity, has improved the model. In any case, this is just a simple demonstration of how spatial predictors generated with functions of the &lt;code&gt;spatialRF&lt;/code&gt; package can still help you fit spatial models with other modeling methods.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R package &#34;vitualPollen&#34;</title>
      <link>/project/virtualpollen/</link>
      <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
      <guid>/project/virtualpollen/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;https://CRAN.R-project.org/package=virtualPollen&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version-ago/virtualPollen&#34; alt=&#34;CRAN\_Release\_Badge&#34;&gt;&lt;/a&gt;

&lt;a href=&#34;https://CRAN.R-project.org/package=virtualPollen&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://cranlogs.r-pkg.org/badges/virtualPollen&#34; alt=&#34;CRAN\_Download\_Badge&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The goal of virtualPollen is to provide the tools to simulate pollen
curves over millenial time-scales generated by virtual taxa with
different life traits (life-span, fecundity, growth-rate) and niche
features (niche position and breadth) as a response to virtual
environmental drivers with a given temporal autocorrelation. It furthers
allow to simulate specific data properties of fossil pollen datasets,
such as sediment accumulation rate, and depth intervals between
consecutive pollen samples. The simulation outcomes are useful to better
understand the role of plant traits, niche properties, and climatic
variability in defining the shape of pollen curves.&lt;/p&gt;
&lt;p&gt;The 
&lt;a href=&#34;https://github.com/BlasBenito/virtualPollen&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub page&lt;/a&gt; of the package offers a complete tutorial on how to use the package. The 
&lt;a href=&#34;https://onlinelibrary.wiley.com/doi/full/10.1111/ecog.04772&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;paper published in the Ecography journal&lt;/a&gt; describes the foundations of the model in brief.&lt;/p&gt;
&lt;p&gt;If you ever use the package, please, cite it as:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Benito, B.M., Gil‐Romera, G. and Birks, H.J.B. (2020), Ecological memory at millennial time‐scales: the importance of data constraints, species longevity and niche features. Ecography, 43: 1-10. &lt;a href=&#34;https://doi.org/10.1111/ecog.04772&#34;&gt;https://doi.org/10.1111/ecog.04772&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
