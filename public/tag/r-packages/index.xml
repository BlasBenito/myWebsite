<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R packages | Blas M. Benito, PhD</title>
    <link>https://blasbenito.com/tag/r-packages/</link>
      <atom:link href="https://blasbenito.com/tag/r-packages/index.xml" rel="self" type="application/rss+xml" />
    <description>R packages</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Mon, 30 Oct 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://blasbenito.com/media/avatar.jpg</url>
      <title>R packages</title>
      <link>https://blasbenito.com/tag/r-packages/</link>
    </image>
    
    <item>
      <title>R package `collinear`</title>
      <link>https://blasbenito.com/project/post-title/</link>
      <pubDate>Mon, 30 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://blasbenito.com/project/post-title/</guid>
      <description>&lt;!-- badges: start --&gt;
&lt;p&gt;
&lt;a href=&#34;https://doi.org/10.5281/zenodo.10039489&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://zenodo.org/badge/DOI/10.5281/zenodo.10039489.svg&#34; alt=&#34;DOI&#34;&gt;&lt;/a&gt;

&lt;a href=&#34;https://cran.r-project.org/package=collinear&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version/collinear&#34; alt=&#34;CRAN status&#34;&gt;&lt;/a&gt;

&lt;a href=&#34;https://CRAN.R-project.org/package=collinear&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;http://cranlogs.r-pkg.org/badges/grand-total/collinear&#34; alt=&#34;CRAN\_Download\_Badge&#34;&gt;&lt;/a&gt;

&lt;a href=&#34;https://github.com/BlasBenito/collinear/actions/workflows/R-CMD-check.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://github.com/BlasBenito/collinear/actions/workflows/R-CMD-check.yaml/badge.svg&#34; alt=&#34;R-CMD-check&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;!-- badges: end --&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;The R package &lt;code&gt;collinear&lt;/code&gt; combines four different methods to offer a comprehensive tool for multicollinearity management:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pairwise correlation for numeric and categorical predictors&lt;/strong&gt;: computed either via Pearson or Spearman methods for numeric predictors, and Cramer&amp;rsquo;s V for categorical predictors.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Variance Inflation Factor analysis (VIF)&lt;/strong&gt;: to identify multicollinearity resulting from predictors being linear combinations of other predictors.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Target encoding of categorical predictors&lt;/strong&gt;: to convert them to numeric using a numeric variable as response (usually a response variable) and handle them as numerics during the multicollinearity filtering.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Variable prioritization&lt;/strong&gt;: method to prioritize predictors during variable selection either using expert knowledge or quantitative criteria.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These methods are integrated in the &lt;code&gt;collinear()&lt;/code&gt; function, which returns a vector of selected predictors with a controlled multicollinearity.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;selected_variables &amp;lt;- collinear(
  df, #your data frame
  response, #name of your response variable
  predictors, #names of your predictors,
  preference_order, #your predictors in order of interest
  max_cor, #maximum bivariate correlation
  max_vif, #maximum variance inflation factor
  encoding_method, #method to convert categorical predictors into numerics
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The package contains other functions that may be useful during multicollinearity management:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cor_select()&lt;/code&gt;: like &lt;code&gt;collinear()&lt;/code&gt;, but only using pairwise correlations.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vif_select()&lt;/code&gt;: like &lt;code&gt;collinear()&lt;/code&gt;, but only using variance inflation factors.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;preference_order()&lt;/code&gt;: to compute preference order based on univariate models.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target_encoding_lab()&lt;/code&gt;: to convert categorical predictors into numeric using several methods.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cor_df()&lt;/code&gt;: to generate a data frame with all pairwise correlation scores.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cor_matrix()&lt;/code&gt;: to convert a correlation data frame into matrix, or obtain a correlation matrix.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vif_df()&lt;/code&gt;: to obtain a data frame with all variance inflation factors.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;citation&#34;&gt;Citation&lt;/h2&gt;
&lt;p&gt;If you found this package useful during your research work, please cite it as:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Blas M. Benito (2023). collinear: R Package for Seamless Multicollinearity Management. Version 1.0.1. doi: 10.5281/zenodo.10039489&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;p&gt;The package &lt;code&gt;collinear&lt;/code&gt; can be installed from CRAN.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&amp;quot;collinear&amp;quot;)
library(collinear)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The development version can be installed from GitHub.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;remotes::install_github(
  repo = &amp;quot;blasbenito/collinear&amp;quot;, 
  ref = &amp;quot;development&amp;quot;
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;multicollinearity-management-with-the-collinear-package&#34;&gt;Multicollinearity management with the &lt;code&gt;collinear&lt;/code&gt; package.&lt;/h2&gt;
&lt;p&gt;This section shows the basic usage of the package and offers a brief explanation on the methods used within.&lt;/p&gt;
&lt;h3 id=&#34;required-libraries-and-example-data&#34;&gt;Required libraries and example data&lt;/h3&gt;
&lt;p&gt;The libraries below are required to run the examples in this section.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(collinear)
library(dplyr)
library(tictoc)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The package &lt;code&gt;collinear&lt;/code&gt; is shipped with a data frame named &lt;code&gt;vi&lt;/code&gt;, with 30.000 rows and 67 columns with a mixture of numeric and categorical variables.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dplyr::glimpse(vi)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Rows: 30,000
## Columns: 67
## $ longitude                  &amp;lt;dbl&amp;gt; -114.254306, 114.845693, -122.145972, 108.3…
## $ latitude                   &amp;lt;dbl&amp;gt; 45.0540272, 26.2706940, 56.3790272, 29.9456…
## $ vi_mean                    &amp;lt;dbl&amp;gt; 0.38, 0.53, 0.45, 0.69, 0.42, 0.68, 0.70, 0…
## $ vi_max                     &amp;lt;dbl&amp;gt; 0.57, 0.67, 0.65, 0.85, 0.64, 0.78, 0.77, 0…
## $ vi_min                     &amp;lt;dbl&amp;gt; 0.12, 0.41, 0.25, 0.50, 0.25, 0.48, 0.60, 0…
## $ vi_range                   &amp;lt;dbl&amp;gt; 0.45, 0.26, 0.40, 0.34, 0.39, 0.31, 0.17, 0…
## $ koppen_zone                &amp;lt;chr&amp;gt; &amp;quot;BSk&amp;quot;, &amp;quot;Cfa&amp;quot;, &amp;quot;Dfc&amp;quot;, &amp;quot;Cfb&amp;quot;, &amp;quot;Aw&amp;quot;, &amp;quot;Cfa&amp;quot;, &amp;quot;A…
## $ koppen_group               &amp;lt;chr&amp;gt; &amp;quot;Arid&amp;quot;, &amp;quot;Temperate&amp;quot;, &amp;quot;Cold&amp;quot;, &amp;quot;Temperate&amp;quot;, &amp;quot;…
## $ koppen_description         &amp;lt;chr&amp;gt; &amp;quot;steppe, cold&amp;quot;, &amp;quot;no dry season, hot summer&amp;quot;…
## $ soil_type                  &amp;lt;chr&amp;gt; &amp;quot;Cambisols&amp;quot;, &amp;quot;Acrisols&amp;quot;, &amp;quot;Luvisols&amp;quot;, &amp;quot;Aliso…
## $ topo_slope                 &amp;lt;int&amp;gt; 6, 2, 0, 10, 0, 10, 6, 0, 2, 0, 0, 1, 0, 1,…
## $ topo_diversity             &amp;lt;int&amp;gt; 29, 24, 21, 25, 19, 30, 26, 20, 26, 22, 25,…
## $ topo_elevation             &amp;lt;int&amp;gt; 1821, 143, 765, 1474, 378, 485, 604, 1159, …
## $ swi_mean                   &amp;lt;dbl&amp;gt; 27.5, 56.1, 41.4, 59.3, 37.4, 56.3, 52.3, 2…
## $ swi_max                    &amp;lt;dbl&amp;gt; 62.9, 74.4, 81.9, 81.1, 83.2, 73.8, 55.8, 3…
## $ swi_min                    &amp;lt;dbl&amp;gt; 24.5, 33.3, 42.2, 31.3, 8.3, 28.8, 25.3, 11…
## $ swi_range                  &amp;lt;dbl&amp;gt; 38.4, 41.2, 39.7, 49.8, 74.9, 45.0, 30.5, 2…
## $ soil_temperature_mean      &amp;lt;dbl&amp;gt; 4.8, 19.9, 1.2, 13.0, 28.2, 18.1, 21.5, 23.…
## $ soil_temperature_max       &amp;lt;dbl&amp;gt; 29.9, 32.6, 20.4, 24.6, 41.6, 29.1, 26.4, 4…
## $ soil_temperature_min       &amp;lt;dbl&amp;gt; -12.4, 3.9, -16.0, -0.4, 16.8, 4.1, 17.3, 5…
## $ soil_temperature_range     &amp;lt;dbl&amp;gt; 42.3, 28.8, 36.4, 25.0, 24.8, 24.9, 9.1, 38…
## $ soil_sand                  &amp;lt;int&amp;gt; 41, 39, 27, 29, 48, 33, 30, 78, 23, 64, 54,…
## $ soil_clay                  &amp;lt;int&amp;gt; 20, 24, 28, 31, 27, 29, 40, 15, 26, 22, 23,…
## $ soil_silt                  &amp;lt;int&amp;gt; 38, 35, 43, 38, 23, 36, 29, 6, 49, 13, 22, …
## $ soil_ph                    &amp;lt;dbl&amp;gt; 6.5, 5.9, 5.6, 5.5, 6.5, 5.8, 5.2, 7.1, 7.3…
## $ soil_soc                   &amp;lt;dbl&amp;gt; 43.1, 14.6, 36.4, 34.9, 8.1, 20.8, 44.5, 4.…
## $ soil_nitrogen              &amp;lt;dbl&amp;gt; 2.8, 1.3, 2.9, 3.6, 1.2, 1.9, 2.8, 0.6, 3.1…
## $ solar_rad_mean             &amp;lt;dbl&amp;gt; 17.634, 19.198, 13.257, 14.163, 24.512, 17.…
## $ solar_rad_max              &amp;lt;dbl&amp;gt; 31.317, 24.498, 25.283, 17.237, 28.038, 22.…
## $ solar_rad_min              &amp;lt;dbl&amp;gt; 5.209, 13.311, 1.587, 9.642, 19.102, 12.196…
## $ solar_rad_range            &amp;lt;dbl&amp;gt; 26.108, 11.187, 23.696, 7.595, 8.936, 10.20…
## $ growing_season_length      &amp;lt;dbl&amp;gt; 139, 365, 164, 333, 228, 365, 365, 60, 365,…
## $ growing_season_temperature &amp;lt;dbl&amp;gt; 12.65, 19.35, 11.55, 12.45, 26.45, 17.75, 2…
## $ growing_season_rainfall    &amp;lt;dbl&amp;gt; 224.5, 1493.4, 345.4, 1765.5, 984.4, 1860.5…
## $ growing_degree_days        &amp;lt;dbl&amp;gt; 2140.5, 7080.9, 2053.2, 4162.9, 10036.7, 64…
## $ temperature_mean           &amp;lt;dbl&amp;gt; 3.65, 19.35, 1.45, 11.35, 27.55, 17.65, 22.…
## $ temperature_max            &amp;lt;dbl&amp;gt; 24.65, 33.35, 21.15, 23.75, 38.35, 30.55, 2…
## $ temperature_min            &amp;lt;dbl&amp;gt; -14.05, 3.05, -18.25, -3.55, 19.15, 2.45, 1…
## $ temperature_range          &amp;lt;dbl&amp;gt; 38.7, 30.3, 39.4, 27.3, 19.2, 28.1, 7.0, 29…
## $ temperature_seasonality    &amp;lt;dbl&amp;gt; 882.6, 786.6, 1070.9, 724.7, 219.3, 747.2, …
## $ rainfall_mean              &amp;lt;int&amp;gt; 446, 1493, 560, 1794, 990, 1860, 3150, 356,…
## $ rainfall_min               &amp;lt;int&amp;gt; 25, 37, 24, 29, 0, 60, 122, 1, 10, 12, 0, 0…
## $ rainfall_max               &amp;lt;int&amp;gt; 62, 209, 87, 293, 226, 275, 425, 62, 256, 3…
## $ rainfall_range             &amp;lt;int&amp;gt; 37, 172, 63, 264, 226, 215, 303, 61, 245, 2…
## $ evapotranspiration_mean    &amp;lt;dbl&amp;gt; 78.32, 105.88, 50.03, 64.65, 156.60, 108.50…
## $ evapotranspiration_max     &amp;lt;dbl&amp;gt; 164.70, 190.86, 117.53, 115.79, 187.71, 191…
## $ evapotranspiration_min     &amp;lt;dbl&amp;gt; 13.67, 50.44, 3.53, 28.01, 128.59, 51.39, 8…
## $ evapotranspiration_range   &amp;lt;dbl&amp;gt; 151.03, 140.42, 113.99, 87.79, 59.13, 139.9…
## $ cloud_cover_mean           &amp;lt;int&amp;gt; 31, 48, 42, 64, 38, 52, 60, 13, 53, 20, 11,…
## $ cloud_cover_max            &amp;lt;int&amp;gt; 39, 61, 49, 71, 58, 67, 77, 18, 60, 27, 23,…
## $ cloud_cover_min            &amp;lt;int&amp;gt; 16, 34, 33, 54, 19, 39, 45, 6, 45, 14, 2, 1…
## $ cloud_cover_range          &amp;lt;int&amp;gt; 23, 27, 15, 17, 38, 27, 32, 11, 15, 12, 21,…
## $ aridity_index              &amp;lt;dbl&amp;gt; 0.54, 1.27, 0.90, 2.08, 0.55, 1.67, 2.88, 0…
## $ humidity_mean              &amp;lt;dbl&amp;gt; 55.56, 62.14, 59.87, 69.32, 51.60, 62.76, 7…
## $ humidity_max               &amp;lt;dbl&amp;gt; 63.98, 65.00, 68.19, 71.90, 67.07, 65.68, 7…
## $ humidity_min               &amp;lt;dbl&amp;gt; 48.41, 58.97, 53.75, 67.21, 33.89, 59.92, 7…
## $ humidity_range             &amp;lt;dbl&amp;gt; 15.57, 6.03, 14.44, 4.69, 33.18, 5.76, 3.99…
## $ biogeo_ecoregion           &amp;lt;chr&amp;gt; &amp;quot;South Central Rockies forests&amp;quot;, &amp;quot;Jian Nan …
## $ biogeo_biome               &amp;lt;chr&amp;gt; &amp;quot;Temperate Conifer Forests&amp;quot;, &amp;quot;Tropical &amp;amp; Su…
## $ biogeo_realm               &amp;lt;chr&amp;gt; &amp;quot;Nearctic&amp;quot;, &amp;quot;Indomalayan&amp;quot;, &amp;quot;Nearctic&amp;quot;, &amp;quot;Pal…
## $ country_name               &amp;lt;chr&amp;gt; &amp;quot;United States of America&amp;quot;, &amp;quot;China&amp;quot;, &amp;quot;Canad…
## $ country_population         &amp;lt;dbl&amp;gt; 313973000, 1338612970, 33487208, 1338612970…
## $ country_gdp                &amp;lt;dbl&amp;gt; 15094000, 7973000, 1300000, 7973000, 15860,…
## $ country_income             &amp;lt;chr&amp;gt; &amp;quot;1. High income: OECD&amp;quot;, &amp;quot;3. Upper middle in…
## $ continent                  &amp;lt;chr&amp;gt; &amp;quot;North America&amp;quot;, &amp;quot;Asia&amp;quot;, &amp;quot;North America&amp;quot;, &amp;quot;…
## $ region                     &amp;lt;chr&amp;gt; &amp;quot;Americas&amp;quot;, &amp;quot;Asia&amp;quot;, &amp;quot;Americas&amp;quot;, &amp;quot;Asia&amp;quot;, &amp;quot;Af…
## $ subregion                  &amp;lt;chr&amp;gt; &amp;quot;Northern America&amp;quot;, &amp;quot;Eastern Asia&amp;quot;, &amp;quot;Northe…
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The response variables are &amp;ldquo;vi_mean&amp;rdquo;, &amp;ldquo;vi_max&amp;rdquo;, &amp;ldquo;vi_min&amp;rdquo;, and &amp;ldquo;vi_range&amp;rdquo;, with statistics of a vegetation index named NDVI. The predictors are stored in the character vector &lt;code&gt;vi_predictors&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;vi_predictors
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;koppen_zone&amp;quot;                &amp;quot;koppen_group&amp;quot;              
##  [3] &amp;quot;koppen_description&amp;quot;         &amp;quot;soil_type&amp;quot;                 
##  [5] &amp;quot;topo_slope&amp;quot;                 &amp;quot;topo_diversity&amp;quot;            
##  [7] &amp;quot;topo_elevation&amp;quot;             &amp;quot;swi_mean&amp;quot;                  
##  [9] &amp;quot;swi_max&amp;quot;                    &amp;quot;swi_min&amp;quot;                   
## [11] &amp;quot;swi_range&amp;quot;                  &amp;quot;soil_temperature_mean&amp;quot;     
## [13] &amp;quot;soil_temperature_max&amp;quot;       &amp;quot;soil_temperature_min&amp;quot;      
## [15] &amp;quot;soil_temperature_range&amp;quot;     &amp;quot;soil_sand&amp;quot;                 
## [17] &amp;quot;soil_clay&amp;quot;                  &amp;quot;soil_silt&amp;quot;                 
## [19] &amp;quot;soil_ph&amp;quot;                    &amp;quot;soil_soc&amp;quot;                  
## [21] &amp;quot;soil_nitrogen&amp;quot;              &amp;quot;solar_rad_mean&amp;quot;            
## [23] &amp;quot;solar_rad_max&amp;quot;              &amp;quot;solar_rad_min&amp;quot;             
## [25] &amp;quot;solar_rad_range&amp;quot;            &amp;quot;growing_season_length&amp;quot;     
## [27] &amp;quot;growing_season_temperature&amp;quot; &amp;quot;growing_season_rainfall&amp;quot;   
## [29] &amp;quot;growing_degree_days&amp;quot;        &amp;quot;temperature_mean&amp;quot;          
## [31] &amp;quot;temperature_max&amp;quot;            &amp;quot;temperature_min&amp;quot;           
## [33] &amp;quot;temperature_range&amp;quot;          &amp;quot;temperature_seasonality&amp;quot;   
## [35] &amp;quot;rainfall_mean&amp;quot;              &amp;quot;rainfall_min&amp;quot;              
## [37] &amp;quot;rainfall_max&amp;quot;               &amp;quot;rainfall_range&amp;quot;            
## [39] &amp;quot;evapotranspiration_mean&amp;quot;    &amp;quot;evapotranspiration_max&amp;quot;    
## [41] &amp;quot;evapotranspiration_min&amp;quot;     &amp;quot;evapotranspiration_range&amp;quot;  
## [43] &amp;quot;cloud_cover_mean&amp;quot;           &amp;quot;cloud_cover_max&amp;quot;           
## [45] &amp;quot;cloud_cover_min&amp;quot;            &amp;quot;cloud_cover_range&amp;quot;         
## [47] &amp;quot;aridity_index&amp;quot;              &amp;quot;humidity_mean&amp;quot;             
## [49] &amp;quot;humidity_max&amp;quot;               &amp;quot;humidity_min&amp;quot;              
## [51] &amp;quot;humidity_range&amp;quot;             &amp;quot;biogeo_ecoregion&amp;quot;          
## [53] &amp;quot;biogeo_biome&amp;quot;               &amp;quot;biogeo_realm&amp;quot;              
## [55] &amp;quot;country_name&amp;quot;               &amp;quot;country_population&amp;quot;        
## [57] &amp;quot;country_gdp&amp;quot;                &amp;quot;country_income&amp;quot;            
## [59] &amp;quot;continent&amp;quot;                  &amp;quot;region&amp;quot;                    
## [61] &amp;quot;subregion&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;collinear&#34;&gt;&lt;code&gt;collinear()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;collinear()&lt;/code&gt; function applies a multicollinearity filtering to numeric and categorical variables via pairwise correlations (with &lt;code&gt;cor_select()&lt;/code&gt;) and variance inflation factors (with &lt;code&gt;vif_select()&lt;/code&gt;). Categorical variables are converted into numeric via target-encoding (with &lt;code&gt;target_encoding_lab()&lt;/code&gt;) using a &lt;code&gt;response&lt;/code&gt; variable as reference. If the response variable is not provided, categorical variables are ignored.&lt;/p&gt;
&lt;h4 id=&#34;input-arguments&#34;&gt;Input arguments&lt;/h4&gt;
&lt;p&gt;The function takes these inputs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;df&lt;/code&gt;: a data frame with predictors, and preferably, a response (more about this later).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;response&lt;/code&gt;: the name of the response variable, only relevant &lt;strong&gt;and highly recommended&lt;/strong&gt; if there are categorical variables within the predictors.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predictors&lt;/code&gt;: names of predictors involved in the multicollinearity analysis.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;preference_order&lt;/code&gt;: names of the predictors in the user&amp;rsquo;s order of preference. Does not need to name all predictors in &lt;code&gt;predictors&lt;/code&gt;!&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cor_method&lt;/code&gt;: usually &amp;ldquo;pearson&amp;rdquo;, but also &amp;ldquo;spearman&amp;rdquo; is accepted.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_cor&lt;/code&gt;: maximum correlation allowed between two predictors.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_vif&lt;/code&gt;: maximum VIF allowed in a predictor.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoding_method&lt;/code&gt;: method used to convert categorical variables into numeric. Only relevant when a &lt;code&gt;response&lt;/code&gt; is provided. By default, each group of the categorical variable is encoded with the mean of the &lt;code&gt;response&lt;/code&gt; across the group.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The code below shows a quick example. Notice that the argument &lt;code&gt;preference_order&lt;/code&gt; was left as NULL, but will be explained later.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;selected_predictors &amp;lt;- collinear(
  df = vi,
  response = &amp;quot;vi_mean&amp;quot;,
  predictors = vi_predictors,
  preference_order = NULL,
  max_cor = 0.75,
  max_vif = 5,
  encoding_method = &amp;quot;mean&amp;quot;
)

selected_predictors
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;country_income&amp;quot;             &amp;quot;topo_diversity&amp;quot;            
##  [3] &amp;quot;topo_slope&amp;quot;                 &amp;quot;humidity_range&amp;quot;            
##  [5] &amp;quot;topo_elevation&amp;quot;             &amp;quot;country_gdp&amp;quot;               
##  [7] &amp;quot;country_population&amp;quot;         &amp;quot;soil_soc&amp;quot;                  
##  [9] &amp;quot;region&amp;quot;                     &amp;quot;soil_type&amp;quot;                 
## [11] &amp;quot;soil_clay&amp;quot;                  &amp;quot;subregion&amp;quot;                 
## [13] &amp;quot;biogeo_realm&amp;quot;               &amp;quot;soil_sand&amp;quot;                 
## [15] &amp;quot;swi_min&amp;quot;                    &amp;quot;soil_nitrogen&amp;quot;             
## [17] &amp;quot;swi_range&amp;quot;                  &amp;quot;cloud_cover_range&amp;quot;         
## [19] &amp;quot;rainfall_min&amp;quot;               &amp;quot;growing_season_temperature&amp;quot;
## [21] &amp;quot;solar_rad_max&amp;quot;              &amp;quot;solar_rad_min&amp;quot;             
## [23] &amp;quot;rainfall_range&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function has returned a list of predictors that should have a correlation lower than 0.75 with each other, and a VIF lower than 5. Let&amp;rsquo;s see if that&amp;rsquo;s true.&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;cor_df()&lt;/code&gt; returns a data frame with pairwise correlations, arranged by the absolute value of the correlation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;selected_predictors_cor &amp;lt;- cor_df(
  df = vi,
  response = &amp;quot;vi_mean&amp;quot;,
  predictors = selected_predictors
)
head(selected_predictors_cor)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 × 3
##   x             y                          correlation
##   &amp;lt;chr&amp;gt;         &amp;lt;chr&amp;gt;                            &amp;lt;dbl&amp;gt;
## 1 solar_rad_min growing_season_temperature       0.744
## 2 soil_nitrogen soil_soc                         0.729
## 3 soil_nitrogen swi_min                          0.673
## 4 soil_sand     soil_clay                       -0.666
## 5 solar_rad_max soil_type                       -0.652
## 6 biogeo_realm  soil_type                        0.62
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The data frame above shows that the maximum correlation between two of the selected predictors is below 0.75, so here &lt;code&gt;collinear()&lt;/code&gt; worked as expected.&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;vif_df()&lt;/code&gt; returns a data frame with the VIF scores of all predictors.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;selected_predictors_vif &amp;lt;- vif_df(
  df = vi,
  response = &amp;quot;vi_mean&amp;quot;,
  predictors = selected_predictors
)
selected_predictors_vif
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                      variable   vif
## 1              country_income 1.211
## 2              topo_diversity 1.635
## 3                  topo_slope 1.928
## 4              humidity_range 1.959
## 5              topo_elevation 2.073
## 6                 country_gdp 2.157
## 7          country_population 2.169
## 8                rainfall_min 2.256
## 9           cloud_cover_range 2.393
## 10             rainfall_range 2.716
## 11                   soil_soc 2.744
## 12                     region 2.846
## 13                  subregion 2.870
## 14                  soil_type 2.874
## 15                  soil_clay 2.966
## 16               biogeo_realm 3.120
## 17              solar_rad_max 3.126
## 18                    swi_min 3.138
## 19                  soil_sand 3.170
## 20                  swi_range 3.263
## 21              soil_nitrogen 3.372
## 22 growing_season_temperature 4.271
## 23              solar_rad_min 4.287
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output shows that the maximum VIF is 4.2, so here &lt;code&gt;collinear()&lt;/code&gt; did its work as expected.&lt;/p&gt;
&lt;h4 id=&#34;arguments-max_cor-and-max_vif&#34;&gt;Arguments &lt;code&gt;max_cor&lt;/code&gt; and &lt;code&gt;max_vif&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;The arguments &lt;code&gt;max_cor&lt;/code&gt; and &lt;code&gt;max_vif&lt;/code&gt; control the intensity of the multicollinearity filtering.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#restrictive setup
selected_predictors_restrictive &amp;lt;- collinear(
  df = vi,
  response = &amp;quot;vi_mean&amp;quot;,
  predictors = vi_predictors,
  max_cor = 0.5,
  max_vif = 2.5
)

#permissive setup
selected_predictors_permissive &amp;lt;- collinear(
  df = vi,
  response = &amp;quot;vi_mean&amp;quot;,
  predictors = vi_predictors,
  max_cor = 0.9,
  max_vif = 10
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These are the variables selected under a restrictive setup:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;selected_predictors_restrictive
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;country_income&amp;quot;             &amp;quot;soil_clay&amp;quot;                 
##  [3] &amp;quot;country_population&amp;quot;         &amp;quot;region&amp;quot;                    
##  [5] &amp;quot;soil_soc&amp;quot;                   &amp;quot;topo_slope&amp;quot;                
##  [7] &amp;quot;growing_season_temperature&amp;quot; &amp;quot;humidity_range&amp;quot;            
##  [9] &amp;quot;cloud_cover_range&amp;quot;          &amp;quot;topo_elevation&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These are the variables selected under a more permissive setup:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;selected_predictors_permissive
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;country_income&amp;quot;             &amp;quot;topo_diversity&amp;quot;            
##  [3] &amp;quot;topo_slope&amp;quot;                 &amp;quot;country_population&amp;quot;        
##  [5] &amp;quot;country_gdp&amp;quot;                &amp;quot;soil_soc&amp;quot;                  
##  [7] &amp;quot;region&amp;quot;                     &amp;quot;soil_type&amp;quot;                 
##  [9] &amp;quot;soil_nitrogen&amp;quot;              &amp;quot;subregion&amp;quot;                 
## [11] &amp;quot;topo_elevation&amp;quot;             &amp;quot;biogeo_realm&amp;quot;              
## [13] &amp;quot;koppen_group&amp;quot;               &amp;quot;biogeo_biome&amp;quot;              
## [15] &amp;quot;country_name&amp;quot;               &amp;quot;soil_ph&amp;quot;                   
## [17] &amp;quot;growing_season_temperature&amp;quot; &amp;quot;aridity_index&amp;quot;             
## [19] &amp;quot;soil_temperature_max&amp;quot;       &amp;quot;rainfall_min&amp;quot;              
## [21] &amp;quot;rainfall_range&amp;quot;             &amp;quot;swi_mean&amp;quot;                  
## [23] &amp;quot;temperature_max&amp;quot;            &amp;quot;solar_rad_mean&amp;quot;            
## [25] &amp;quot;soil_clay&amp;quot;                  &amp;quot;soil_silt&amp;quot;                 
## [27] &amp;quot;cloud_cover_min&amp;quot;            &amp;quot;swi_range&amp;quot;                 
## [29] &amp;quot;humidity_range&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, the restrictive setup resulted in a smaller set of selected predictors. There are no hard rules for &lt;code&gt;max_cor&lt;/code&gt; and &lt;code&gt;max_vif&lt;/code&gt;, and their selection will depend on the objective of the analysis and the nature of the predictors.&lt;/p&gt;
&lt;h4 id=&#34;the-response-argument&#34;&gt;The &lt;code&gt;response&lt;/code&gt; argument&lt;/h4&gt;
&lt;p&gt;The response argument is used to encode categorical variables as numeric. When omitted, the &lt;code&gt;collinear()&lt;/code&gt; function ignores categorical variables. However, the function &lt;code&gt;cor_select()&lt;/code&gt; can help when there is not a suitable &lt;code&gt;response&lt;/code&gt; variable in a data frame. This option is discussed at the end of this section.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;selected_predictors_response &amp;lt;- collinear(
  df = vi,
  response = &amp;quot;vi_mean&amp;quot;,
  predictors = vi_predictors
)

selected_predictors_no_response &amp;lt;- collinear(
  df = vi,
  predictors = vi_predictors
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the argument &lt;code&gt;response&lt;/code&gt; is used, the output may contain categorical predictors (tagged with &lt;code&gt;&amp;lt;chr&amp;gt;&lt;/code&gt;, from &amp;ldquo;character&amp;rdquo; below).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dplyr::glimpse(vi[, selected_predictors_response])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Rows: 30,000
## Columns: 23
## $ country_income             &amp;lt;chr&amp;gt; &amp;quot;1. High income: OECD&amp;quot;, &amp;quot;3. Upper middle in…
## $ topo_diversity             &amp;lt;int&amp;gt; 29, 24, 21, 25, 19, 30, 26, 20, 26, 22, 25,…
## $ topo_slope                 &amp;lt;int&amp;gt; 6, 2, 0, 10, 0, 10, 6, 0, 2, 0, 0, 1, 0, 1,…
## $ humidity_range             &amp;lt;dbl&amp;gt; 15.57, 6.03, 14.44, 4.69, 33.18, 5.76, 3.99…
## $ topo_elevation             &amp;lt;int&amp;gt; 1821, 143, 765, 1474, 378, 485, 604, 1159, …
## $ country_gdp                &amp;lt;dbl&amp;gt; 15094000, 7973000, 1300000, 7973000, 15860,…
## $ country_population         &amp;lt;dbl&amp;gt; 313973000, 1338612970, 33487208, 1338612970…
## $ soil_soc                   &amp;lt;dbl&amp;gt; 43.1, 14.6, 36.4, 34.9, 8.1, 20.8, 44.5, 4.…
## $ region                     &amp;lt;chr&amp;gt; &amp;quot;Americas&amp;quot;, &amp;quot;Asia&amp;quot;, &amp;quot;Americas&amp;quot;, &amp;quot;Asia&amp;quot;, &amp;quot;Af…
## $ soil_type                  &amp;lt;chr&amp;gt; &amp;quot;Cambisols&amp;quot;, &amp;quot;Acrisols&amp;quot;, &amp;quot;Luvisols&amp;quot;, &amp;quot;Aliso…
## $ soil_clay                  &amp;lt;int&amp;gt; 20, 24, 28, 31, 27, 29, 40, 15, 26, 22, 23,…
## $ subregion                  &amp;lt;chr&amp;gt; &amp;quot;Northern America&amp;quot;, &amp;quot;Eastern Asia&amp;quot;, &amp;quot;Northe…
## $ biogeo_realm               &amp;lt;chr&amp;gt; &amp;quot;Nearctic&amp;quot;, &amp;quot;Indomalayan&amp;quot;, &amp;quot;Nearctic&amp;quot;, &amp;quot;Pal…
## $ soil_sand                  &amp;lt;int&amp;gt; 41, 39, 27, 29, 48, 33, 30, 78, 23, 64, 54,…
## $ swi_min                    &amp;lt;dbl&amp;gt; 24.5, 33.3, 42.2, 31.3, 8.3, 28.8, 25.3, 11…
## $ soil_nitrogen              &amp;lt;dbl&amp;gt; 2.8, 1.3, 2.9, 3.6, 1.2, 1.9, 2.8, 0.6, 3.1…
## $ swi_range                  &amp;lt;dbl&amp;gt; 38.4, 41.2, 39.7, 49.8, 74.9, 45.0, 30.5, 2…
## $ cloud_cover_range          &amp;lt;int&amp;gt; 23, 27, 15, 17, 38, 27, 32, 11, 15, 12, 21,…
## $ rainfall_min               &amp;lt;int&amp;gt; 25, 37, 24, 29, 0, 60, 122, 1, 10, 12, 0, 0…
## $ growing_season_temperature &amp;lt;dbl&amp;gt; 12.65, 19.35, 11.55, 12.45, 26.45, 17.75, 2…
## $ solar_rad_max              &amp;lt;dbl&amp;gt; 31.317, 24.498, 25.283, 17.237, 28.038, 22.…
## $ solar_rad_min              &amp;lt;dbl&amp;gt; 5.209, 13.311, 1.587, 9.642, 19.102, 12.196…
## $ rainfall_range             &amp;lt;int&amp;gt; 37, 172, 63, 264, 226, 215, 303, 61, 245, 2…
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, when the argument &lt;code&gt;response&lt;/code&gt; is ignored, all categorical predictors are ignored.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;dplyr::glimpse(vi[, selected_predictors_no_response])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Rows: 30,000
## Columns: 18
## $ topo_diversity             &amp;lt;int&amp;gt; 29, 24, 21, 25, 19, 30, 26, 20, 26, 22, 25,…
## $ humidity_range             &amp;lt;dbl&amp;gt; 15.57, 6.03, 14.44, 4.69, 33.18, 5.76, 3.99…
## $ country_population         &amp;lt;dbl&amp;gt; 313973000, 1338612970, 33487208, 1338612970…
## $ country_gdp                &amp;lt;dbl&amp;gt; 15094000, 7973000, 1300000, 7973000, 15860,…
## $ topo_slope                 &amp;lt;int&amp;gt; 6, 2, 0, 10, 0, 10, 6, 0, 2, 0, 0, 1, 0, 1,…
## $ topo_elevation             &amp;lt;int&amp;gt; 1821, 143, 765, 1474, 378, 485, 604, 1159, …
## $ swi_range                  &amp;lt;dbl&amp;gt; 38.4, 41.2, 39.7, 49.8, 74.9, 45.0, 30.5, 2…
## $ soil_soc                   &amp;lt;dbl&amp;gt; 43.1, 14.6, 36.4, 34.9, 8.1, 20.8, 44.5, 4.…
## $ soil_clay                  &amp;lt;int&amp;gt; 20, 24, 28, 31, 27, 29, 40, 15, 26, 22, 23,…
## $ soil_sand                  &amp;lt;int&amp;gt; 41, 39, 27, 29, 48, 33, 30, 78, 23, 64, 54,…
## $ swi_min                    &amp;lt;dbl&amp;gt; 24.5, 33.3, 42.2, 31.3, 8.3, 28.8, 25.3, 11…
## $ soil_nitrogen              &amp;lt;dbl&amp;gt; 2.8, 1.3, 2.9, 3.6, 1.2, 1.9, 2.8, 0.6, 3.1…
## $ cloud_cover_range          &amp;lt;int&amp;gt; 23, 27, 15, 17, 38, 27, 32, 11, 15, 12, 21,…
## $ growing_season_temperature &amp;lt;dbl&amp;gt; 12.65, 19.35, 11.55, 12.45, 26.45, 17.75, 2…
## $ rainfall_min               &amp;lt;int&amp;gt; 25, 37, 24, 29, 0, 60, 122, 1, 10, 12, 0, 0…
## $ solar_rad_max              &amp;lt;dbl&amp;gt; 31.317, 24.498, 25.283, 17.237, 28.038, 22.…
## $ solar_rad_min              &amp;lt;dbl&amp;gt; 5.209, 13.311, 1.587, 9.642, 19.102, 12.196…
## $ rainfall_range             &amp;lt;int&amp;gt; 37, 172, 63, 264, 226, 215, 303, 61, 245, 2…
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If there are categorical variables in a data frame, but there is no suitable &lt;code&gt;response&lt;/code&gt; variable, then the function &lt;code&gt;cor_select()&lt;/code&gt; can handle the multicollinearity management via pairwise correlations, but at a MUCH higher computational cost, and with different results, as shown below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tictoc::tic()
selected_predictors_response &amp;lt;- cor_select(
  df = vi,
  response = &amp;quot;vi_mean&amp;quot;,
  predictors = vi_predictors
)
tictoc::toc()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 0.48 sec elapsed
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;tictoc::tic()
selected_predictors_no_response &amp;lt;- cor_select(
  df = vi,
  predictors = vi_predictors
)
tictoc::toc()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 41.254 sec elapsed
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;selected_predictors_response
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;country_population&amp;quot;         &amp;quot;topo_elevation&amp;quot;            
##  [3] &amp;quot;country_income&amp;quot;             &amp;quot;country_gdp&amp;quot;               
##  [5] &amp;quot;topo_slope&amp;quot;                 &amp;quot;humidity_range&amp;quot;            
##  [7] &amp;quot;soil_clay&amp;quot;                  &amp;quot;topo_diversity&amp;quot;            
##  [9] &amp;quot;soil_sand&amp;quot;                  &amp;quot;cloud_cover_range&amp;quot;         
## [11] &amp;quot;region&amp;quot;                     &amp;quot;growing_season_temperature&amp;quot;
## [13] &amp;quot;solar_rad_min&amp;quot;              &amp;quot;soil_soc&amp;quot;                  
## [15] &amp;quot;rainfall_min&amp;quot;               &amp;quot;swi_range&amp;quot;                 
## [17] &amp;quot;soil_nitrogen&amp;quot;              &amp;quot;rainfall_range&amp;quot;            
## [19] &amp;quot;swi_min&amp;quot;                    &amp;quot;subregion&amp;quot;                 
## [21] &amp;quot;biogeo_realm&amp;quot;               &amp;quot;cloud_cover_min&amp;quot;           
## [23] &amp;quot;soil_type&amp;quot;                  &amp;quot;aridity_index&amp;quot;             
## [25] &amp;quot;solar_rad_max&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;selected_predictors_no_response
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;topo_elevation&amp;quot;             &amp;quot;topo_slope&amp;quot;                
##  [3] &amp;quot;country_population&amp;quot;         &amp;quot;topo_diversity&amp;quot;            
##  [5] &amp;quot;soil_clay&amp;quot;                  &amp;quot;humidity_range&amp;quot;            
##  [7] &amp;quot;soil_sand&amp;quot;                  &amp;quot;country_gdp&amp;quot;               
##  [9] &amp;quot;cloud_cover_range&amp;quot;          &amp;quot;country_income&amp;quot;            
## [11] &amp;quot;rainfall_min&amp;quot;               &amp;quot;soil_soc&amp;quot;                  
## [13] &amp;quot;swi_range&amp;quot;                  &amp;quot;growing_season_temperature&amp;quot;
## [15] &amp;quot;rainfall_range&amp;quot;             &amp;quot;soil_nitrogen&amp;quot;             
## [17] &amp;quot;solar_rad_min&amp;quot;              &amp;quot;aridity_index&amp;quot;             
## [19] &amp;quot;cloud_cover_min&amp;quot;            &amp;quot;temperature_max&amp;quot;           
## [21] &amp;quot;region&amp;quot;                     &amp;quot;swi_min&amp;quot;                   
## [23] &amp;quot;solar_rad_max&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The variable selection results differ because the numeric representations of the categorical variables are rather different between the two options. When no &lt;code&gt;response&lt;/code&gt; is provided, the function &lt;code&gt;cor_select()&lt;/code&gt; compares categorical predictors against numeric ones by encoding each categorical after each numeric, and compares pairs of categoricals using Cramer&amp;rsquo;s V, implemented in the function &lt;code&gt;cramer_v()&lt;/code&gt;. Additionally, Cramer&amp;rsquo;s V values are not directly comparable with Pearson or Spearman correlation scores, and having them together in the same analysis might induce bias during the variable selection. Not using the &lt;code&gt;response&lt;/code&gt; argument should always be the last option.&lt;/p&gt;
&lt;h4 id=&#34;preference-order&#34;&gt;Preference order&lt;/h4&gt;
&lt;p&gt;The argument &lt;code&gt;preference_order&lt;/code&gt; gives the user some control on what predictors should be removed first and what predictors should be kept during the multicollinearity filtering. This argument accepts a vector of predictor names in the order of interest, or the result of the function &lt;code&gt;preference_order()&lt;/code&gt;, which allows to define preference order following a quantitative criteria.&lt;/p&gt;
&lt;h5 id=&#34;manual-preference-order&#34;&gt;Manual preference order&lt;/h5&gt;
&lt;p&gt;Let&amp;rsquo;s start with the former option. Below, the argument &lt;code&gt;preference_order&lt;/code&gt; names several predictors that are of importance for a hypothetical analysis. The &lt;code&gt;predictors&lt;/code&gt; not in &lt;code&gt;preference_order&lt;/code&gt; are ranked by the absolute sum of their correlations with other predictors during the pairwise correlation filtering, and by their VIF during the VIF-based filtering.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;selected_predictors &amp;lt;- cor_select(
  df = vi,
  response = &amp;quot;vi_mean&amp;quot;,
  predictors = vi_predictors,
  preference_order = c(
    &amp;quot;soil_temperature_mean&amp;quot;,
    &amp;quot;soil_temperature_max&amp;quot;,
    &amp;quot;soil_type&amp;quot;
  )
)

selected_predictors
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;soil_temperature_mean&amp;quot; &amp;quot;soil_temperature_max&amp;quot;  &amp;quot;soil_type&amp;quot;            
##  [4] &amp;quot;country_population&amp;quot;    &amp;quot;topo_elevation&amp;quot;        &amp;quot;country_income&amp;quot;       
##  [7] &amp;quot;country_gdp&amp;quot;           &amp;quot;topo_slope&amp;quot;            &amp;quot;humidity_range&amp;quot;       
## [10] &amp;quot;soil_clay&amp;quot;             &amp;quot;topo_diversity&amp;quot;        &amp;quot;soil_sand&amp;quot;            
## [13] &amp;quot;cloud_cover_range&amp;quot;     &amp;quot;region&amp;quot;                &amp;quot;soil_soc&amp;quot;             
## [16] &amp;quot;rainfall_min&amp;quot;          &amp;quot;swi_range&amp;quot;             &amp;quot;soil_nitrogen&amp;quot;        
## [19] &amp;quot;rainfall_range&amp;quot;        &amp;quot;subregion&amp;quot;             &amp;quot;biogeo_realm&amp;quot;         
## [22] &amp;quot;aridity_index&amp;quot;         &amp;quot;solar_rad_max&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that in the output, two of the variables in &lt;code&gt;preference_order&lt;/code&gt; are selected (&amp;ldquo;soil_temperature_mean&amp;rdquo; and &amp;ldquo;soil_type&amp;rdquo;), but one was removed (&amp;ldquo;soil_temperature_max&amp;rdquo;). This happens because at some point in the selection, the VIF of &amp;ldquo;soil_temperature_mean&amp;rdquo; and &amp;ldquo;soil_temperature_max&amp;rdquo; was higher than &lt;code&gt;max_vif&lt;/code&gt;, and the one with lower preference was removed.&lt;/p&gt;
&lt;h5 id=&#34;quantitative-preference-order&#34;&gt;Quantitative preference order&lt;/h5&gt;
&lt;p&gt;The function &lt;code&gt;preference_order()&lt;/code&gt; requires the &lt;code&gt;response&lt;/code&gt; argument, and takes a function &lt;code&gt;f&lt;/code&gt; that returns a value of association between the response and any predictor. This value is then located in the &amp;ldquo;preference&amp;rdquo; column of the function&amp;rsquo;s output.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;preference_rsquared &amp;lt;- preference_order(
  df = vi,
  response = &amp;quot;vi_mean&amp;quot;,
  predictors = vi_predictors,
  f = f_rsquared,
  workers = 1 #requires package future and future.apply for more workers
)

preference_rsquared
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                     predictor   preference
## 1            biogeo_ecoregion 0.8971347093
## 2       growing_season_length 0.8076216576
## 3                 koppen_zone 0.8050280970
## 4          koppen_description 0.7903458680
## 5                     soil_ph 0.7664428862
## 6                    swi_mean 0.7286901614
## 7               humidity_mean 0.7141389404
## 8                koppen_group 0.6996959734
## 9                biogeo_biome 0.6515724588
## 10               country_name 0.6448346803
## 11           cloud_cover_mean 0.6338773126
## 12                  soil_type 0.6318025761
## 13              rainfall_mean 0.6005761078
## 14               humidity_max 0.5876622545
## 15       soil_temperature_max 0.5827628810
## 16                    swi_max 0.5813558512
## 17            cloud_cover_max 0.5758002449
## 18               humidity_min 0.5705720164
## 19    growing_season_rainfall 0.5697006759
## 20     soil_temperature_range 0.5523074848
## 21               biogeo_realm 0.5031101984
## 22              solar_rad_max 0.4905225950
## 23     evapotranspiration_max 0.4814731607
## 24               rainfall_max 0.4783927311
## 25              aridity_index 0.4506424015
## 26                  subregion 0.4469207404
## 27                  swi_range 0.4217411381
## 28            cloud_cover_min 0.4135724066
## 29   evapotranspiration_range 0.4042241481
## 30          temperature_range 0.3753489250
## 31             rainfall_range 0.3545446680
## 32    temperature_seasonality 0.2499469281
## 33               rainfall_min 0.2484813976
## 34                    swi_min 0.2406964836
## 35             solar_rad_mean 0.2140860965
## 36              soil_nitrogen 0.1872886789
## 37                  continent 0.1818717607
## 38            temperature_max 0.1589418736
## 39                     region 0.1505256024
## 40                   soil_soc 0.1493958026
## 41    evapotranspiration_mean 0.1455828419
## 42            solar_rad_range 0.1300751363
## 43            temperature_min 0.1222051434
## 44          cloud_cover_range 0.1216812855
## 45       soil_temperature_min 0.1018471531
## 46             topo_diversity 0.0925948262
## 47                  soil_clay 0.0769366113
## 48             humidity_range 0.0575393339
## 49             country_income 0.0489946403
## 50                  soil_sand 0.0427943817
## 51             topo_elevation 0.0424759731
## 52 growing_season_temperature 0.0239161476
## 53                 topo_slope 0.0203697134
## 54      soil_temperature_mean 0.0170527033
## 55           temperature_mean 0.0067479780
## 56                  soil_silt 0.0059316757
## 57        growing_degree_days 0.0047849144
## 58     evapotranspiration_min 0.0009965488
## 59                country_gdp 0.0008850479
## 60              solar_rad_min 0.0005751350
## 61         country_population 0.0002513147
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result of &lt;code&gt;preference_order()&lt;/code&gt; can be plugged right away into the &lt;code&gt;preference_order&lt;/code&gt; argument of collinear.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;selected_predictors &amp;lt;- collinear(
  df = vi,
  response = &amp;quot;vi_mean&amp;quot;,
  predictors = vi_predictors,
  preference_order = preference_rsquared
)
selected_predictors
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;biogeo_ecoregion&amp;quot;       &amp;quot;soil_temperature_range&amp;quot; &amp;quot;rainfall_min&amp;quot;          
##  [4] &amp;quot;solar_rad_mean&amp;quot;         &amp;quot;soil_nitrogen&amp;quot;          &amp;quot;continent&amp;quot;             
##  [7] &amp;quot;soil_soc&amp;quot;               &amp;quot;cloud_cover_range&amp;quot;      &amp;quot;topo_diversity&amp;quot;        
## [10] &amp;quot;soil_clay&amp;quot;              &amp;quot;humidity_range&amp;quot;         &amp;quot;country_income&amp;quot;        
## [13] &amp;quot;soil_sand&amp;quot;              &amp;quot;topo_elevation&amp;quot;         &amp;quot;topo_slope&amp;quot;            
## [16] &amp;quot;country_gdp&amp;quot;            &amp;quot;country_population&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This variable selection satisfies three conditions at once: maximum correlation between each predictor and the response, maximum pairwise correlation, and maximum VIF.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;f&lt;/code&gt; argument used by default is the function &lt;code&gt;f_rsquared()&lt;/code&gt;, that returns the R-squared between the response and any predictor.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;f_rsquared(
  x = &amp;quot;growing_season_length&amp;quot;,
  y = &amp;quot;vi_mean&amp;quot;,
  df = vi
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.8076217
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two other &lt;code&gt;f&lt;/code&gt; functions implemented:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f_ga_deviance()&lt;/code&gt;: returns the explained deviance of a univariate GAM model between the response and each predictor, fitted with the function &lt;code&gt;mgcv::gam()&lt;/code&gt;. Only if the R package &lt;code&gt;mgcv&lt;/code&gt; is installed in the system.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f_rf_deviance()&lt;/code&gt;: returns the explained deviance of a univariate Random Forest model between the response and each predictor, fitted with the function &lt;code&gt;ranger::ranger()&lt;/code&gt;. Only if the R package &lt;code&gt;ranger&lt;/code&gt; is installed in the system.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Custom functions created by the user are also accepted as input, as long as they have the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;df&lt;/code&gt; arguments, and they return a single numeric value.&lt;/p&gt;
&lt;p&gt;These can be run in parallel across predictors by increasing the value of the &lt;code&gt;workers&lt;/code&gt; argument if the R packages &lt;code&gt;future&lt;/code&gt; and &lt;code&gt;future.apply&lt;/code&gt; are installed in the system.&lt;/p&gt;
&lt;h3 id=&#34;cor_select-and-vif_select&#34;&gt;&lt;code&gt;cor_select()&lt;/code&gt; and &lt;code&gt;vif_select()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The functions &lt;code&gt;cor_select()&lt;/code&gt; and &lt;code&gt;vif_select()&lt;/code&gt;, called within &lt;code&gt;collinear()&lt;/code&gt;, perform the pairwise correlation filtering, and the VIF-based filtering. The main difference between them is that &lt;code&gt;cor_select()&lt;/code&gt; can handle categorical predictors even when the &lt;code&gt;response&lt;/code&gt; is omitted, while &lt;code&gt;vif_select()&lt;/code&gt; ignores them entirely in such case.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;selected_predictors_cor &amp;lt;- cor_select(
  df = vi,
  response = &amp;quot;vi_mean&amp;quot;,
  predictors = vi_predictors,
  preference_order = preference_rsquared
)

selected_predictors_vif &amp;lt;- vif_select(
  df = vi,
  response = &amp;quot;vi_mean&amp;quot;,
  predictors = vi_predictors,
  preference_order = preference_rsquared
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;selected_predictors_cor
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;biogeo_ecoregion&amp;quot;       &amp;quot;soil_temperature_range&amp;quot; &amp;quot;rainfall_min&amp;quot;          
##  [4] &amp;quot;solar_rad_mean&amp;quot;         &amp;quot;soil_nitrogen&amp;quot;          &amp;quot;continent&amp;quot;             
##  [7] &amp;quot;soil_soc&amp;quot;               &amp;quot;cloud_cover_range&amp;quot;      &amp;quot;topo_diversity&amp;quot;        
## [10] &amp;quot;soil_clay&amp;quot;              &amp;quot;humidity_range&amp;quot;         &amp;quot;country_income&amp;quot;        
## [13] &amp;quot;soil_sand&amp;quot;              &amp;quot;topo_elevation&amp;quot;         &amp;quot;topo_slope&amp;quot;            
## [16] &amp;quot;country_gdp&amp;quot;            &amp;quot;country_population&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;selected_predictors_vif
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;biogeo_ecoregion&amp;quot;   &amp;quot;soil_type&amp;quot;          &amp;quot;rainfall_mean&amp;quot;     
##  [4] &amp;quot;biogeo_realm&amp;quot;       &amp;quot;solar_rad_max&amp;quot;      &amp;quot;subregion&amp;quot;         
##  [7] &amp;quot;soil_nitrogen&amp;quot;      &amp;quot;continent&amp;quot;          &amp;quot;soil_soc&amp;quot;          
## [10] &amp;quot;topo_diversity&amp;quot;     &amp;quot;soil_clay&amp;quot;          &amp;quot;country_income&amp;quot;    
## [13] &amp;quot;soil_sand&amp;quot;          &amp;quot;topo_slope&amp;quot;         &amp;quot;country_gdp&amp;quot;       
## [16] &amp;quot;country_population&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;target_encoding_lab&#34;&gt;&lt;code&gt;target_encoding_lab()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The function &lt;code&gt;target_encoding_lab()&lt;/code&gt; is used within all other functions in the package to encode categorical variables as numeric. It implements four target encoding methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;mean&amp;rdquo; (in &lt;code&gt;target_encoding_mean()&lt;/code&gt;): replaces each category with the mean of the response across the category. White noise can be added to this option to increase data variability.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;rank&amp;rdquo; (in &lt;code&gt;target_encoding_rank()&lt;/code&gt;): replaces each category with the rank of the mean of the response across the category.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;rnorm&amp;rdquo; (in &lt;code&gt;target_encoding_rnorm()&lt;/code&gt;): replaces each value in a category with a number generated by &lt;code&gt;stats::rnorm()&lt;/code&gt; from a normal distribution with the mean and the standard deviation of the response over the category.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;loo&amp;rdquo; (in &lt;code&gt;target_encoding_loo()&lt;/code&gt;): replaces each value in a category with the mean of the response across all the other cases within the category. White noise can be added to this option to increase data variability.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The method &amp;ldquo;mean&amp;rdquo; is used as default throughout all functions in the package, but can be changed via the argument &lt;code&gt;encoding_method&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below we use all methods to generate different numeric encodings for the categorical variable &amp;ldquo;koppen_zone&amp;rdquo;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df &amp;lt;- target_encoding_lab(
  df = vi,
  response = &amp;quot;vi_mean&amp;quot;,
  predictors = &amp;quot;koppen_zone&amp;quot;,
  encoding_methods = c(
    &amp;quot;mean&amp;quot;,
    &amp;quot;rank&amp;quot;,
    &amp;quot;rnorm&amp;quot;,
    &amp;quot;loo&amp;quot;
  ),
  seed = 1,
  rnorm_sd_multiplier = c(0, 0.01, 0.1),
  white_noise = c(0, 0.01, 0.1),
  verbose = TRUE
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Encoding the variables:
## koppen_zone
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## New encoded predictor: &#39;koppen_zone__encoded_rank&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## New encoded predictor: &#39;koppen_zone__encoded_mean&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## New encoded predictor: &#39;koppen_zone__encoded_loo&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## New encoded predictor: &#39;koppen_zone__encoded_mean__white_noise_0.01&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## New encoded predictor: &#39;koppen_zone__encoded_loo__white_noise_0.01&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## New encoded predictor: &#39;koppen_zone__encoded_mean__white_noise_0.1&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## New encoded predictor: &#39;koppen_zone__encoded_loo__white_noise_0.1&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## New encoded predictor: &#39;koppen_zone__encoded_rnorm&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## New encoded predictor: &#39;koppen_zone__encoded_rnorm__sd_multiplier_0.01&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## New encoded predictor: &#39;koppen_zone__encoded_rnorm__sd_multiplier_0.1&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The relationship between these encoded versions of &amp;ldquo;koppen_zone&amp;rdquo; and the response are shown below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#get names of encoded variables
koppen_zone_encoded &amp;lt;- grep(
  pattern = &amp;quot;*__encoded*&amp;quot;,
  x = colnames(df),
  value = TRUE
)

#record the user&#39;s graphical parameters
user.par &amp;lt;- par(no.readonly = TRUE)

#modify graphical parameters for the plot
par(mfrow = c(4, 3))

#plot target encoding
x &amp;lt;- lapply(
  X = koppen_zone_encoded,
  FUN = function(x) plot(
    x = df[[x]],
    y = df$vi_mean,
    xlab = x,
    ylab = &amp;quot;vi_mean&amp;quot;,
    cex = 0.5
    )
)

#reset the user&#39;s graphical parameters
par(user.par)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function implementing each method can be used directly as well. The example below shows the &amp;ldquo;mean&amp;rdquo; method with the option &lt;code&gt;replace = FALSE&lt;/code&gt;, which replaces the categorical values with the numeric ones in the output data frame.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;head(vi[, c(&amp;quot;vi_mean&amp;quot;, &amp;quot;koppen_zone&amp;quot;)], n = 10)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    vi_mean koppen_zone
## 1     0.38         BSk
## 2     0.53         Cfa
## 3     0.45         Dfc
## 4     0.69         Cfb
## 5     0.42          Aw
## 6     0.68         Cfa
## 7     0.70          Af
## 8     0.26         BSh
## 9     0.55         Cwa
## 10    0.16         BWh
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df &amp;lt;- target_encoding_mean(
  df = vi,
  response = &amp;quot;vi_mean&amp;quot;,
  predictor = &amp;quot;koppen_zone&amp;quot;,
  replace = TRUE
)

head(df[, c(&amp;quot;vi_mean&amp;quot;, &amp;quot;koppen_zone&amp;quot;)], n = 10)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    vi_mean koppen_zone
## 1     0.38   0.2487370
## 2     0.53   0.5661689
## 3     0.45   0.4338492
## 4     0.69   0.5889908
## 5     0.42   0.5275241
## 6     0.68   0.5661689
## 7     0.70   0.6708994
## 8     0.26   0.3230049
## 9     0.55   0.5218936
## 10    0.16   0.1330452
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you got here, thank you for your interest in the R package &lt;code&gt;collinear&lt;/code&gt;, I hope it can serve you well.&lt;/p&gt;
&lt;p&gt;And that&amp;rsquo;s a wrap!&lt;/p&gt;
&lt;p&gt;Blas M. Benito, PhD&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Multicollinearity Hinders Model Interpretability</title>
      <link>https://blasbenito.com/post/multicollinearity-model-interpretability/</link>
      <pubDate>Sun, 29 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://blasbenito.com/post/multicollinearity-model-interpretability/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    This post is written for beginner to intermediate R users wishing to learn what multicollinearity is and how it can turn model interpretation into a challenge.
  &lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;
&lt;p&gt;In this post, I delve into the intricacies of model interpretation under the influence of multicollinearity, and use R and a toy data set to demonstrate how this phenomenon impacts both linear and machine learning models:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The section &lt;em&gt;Multicollinearity Explained&lt;/em&gt; explains the origin of the word and the nature of the problem.&lt;/li&gt;
&lt;li&gt;The section &lt;em&gt;Model Interpretation Challenges&lt;/em&gt; describes how to create the toy data set, and applies it to &lt;em&gt;Linear Models&lt;/em&gt; and &lt;em&gt;Random Forest&lt;/em&gt; to explain how multicollinearity can make model interpretation a challenge.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;Appendix&lt;/em&gt; shows extra examples of linear and machine learning models affected by multicollinearity.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I hope you&amp;rsquo;ll enjoy it!&lt;/p&gt;
&lt;h1 id=&#34;r-packages&#34;&gt;R packages&lt;/h1&gt;
&lt;p&gt;This tutorial requires the newly released R package 
&lt;a href=&#34;https://blasbenito.github.io/collinear/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;collinear&lt;/code&gt;&lt;/a&gt;, and a few more listed below. The optional ones are used only in the &lt;em&gt;Appendix&lt;/em&gt; at the end of the post.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#required
install.packages(&amp;quot;collinear&amp;quot;)
install.packages(&amp;quot;ranger&amp;quot;)
install.packages(&amp;quot;dplyr&amp;quot;)

#optional
install.packages(&amp;quot;nlme&amp;quot;)
install.packages(&amp;quot;glmnet&amp;quot;)
install.packages(&amp;quot;xgboost&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;multicollinearity-explained&#34;&gt;Multicollinearity Explained&lt;/h1&gt;
&lt;p&gt;This cute word comes from the amalgamation of these three Latin terms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;multus&lt;/em&gt;: adjective meaning &lt;em&gt;many&lt;/em&gt; or &lt;em&gt;multiple&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;con&lt;/em&gt;: preposition often converted to &lt;em&gt;co-&lt;/em&gt; (as in &lt;em&gt;co-worker&lt;/em&gt;) meaning &lt;em&gt;together&lt;/em&gt; or &lt;em&gt;mutually&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;linealis&lt;/em&gt; (later converted to &lt;em&gt;linearis&lt;/em&gt;): from &lt;em&gt;linea&lt;/em&gt; (line), adjective meaning &amp;ldquo;resembling a line&amp;rdquo; or &amp;ldquo;belonging to a line&amp;rdquo;, among others.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After looking at these serious words, we can come up with a (VERY) liberal translation: &amp;ldquo;several things together in the same line&amp;rdquo;. From here, we just have to replace the word &amp;ldquo;things&amp;rdquo; with &amp;ldquo;predictors&amp;rdquo; (or &amp;ldquo;features&amp;rdquo;, or &amp;ldquo;independent variables&amp;rdquo;, whatever rocks your boat) to build an intuition of the whole meaning of the word in the context of statistical and machine learning modeling.&lt;/p&gt;
&lt;p&gt;If I lost you there, we can move forward with this idea instead: &lt;strong&gt;multicollinearity happens when there are redundant predictors in a modeling dataset&lt;/strong&gt;. A predictor can be redundant because it shows a high pairwise correlation with other predictors, or because it is a linear combination of other predictors. For example, in a data frame with the columns &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, if the correlation between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is high, we can say that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are mutually redundant and there is multicollinearity. But also, if &lt;code&gt;c&lt;/code&gt; is the result of a linear operation between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, like &lt;code&gt;c &amp;lt;- a + b&lt;/code&gt;, or &lt;code&gt;c &amp;lt;- a * 1 + b * 0.5&lt;/code&gt;, then we can also say that there is multicollinearity between &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Multicollinearity is a fact of life that lurks in most data sets. For example, in climate data, variables like temperature, humidity and air pressure are closely intertwined, leading to multicollinearity. That&amp;rsquo;s the case as well in medical research, where parameters like blood pressure, heart rate, and body mass index frequently display common patterns. Economic analysis is another good example, as variables such as Gross Domestic Product (GDP), unemployment rate, and consumer spending often exhibit multicollinearity.&lt;/p&gt;
&lt;h1 id=&#34;model-interpretation-challenges&#34;&gt;Model Interpretation Challenges&lt;/h1&gt;
&lt;p&gt;Multicollinearity isn&amp;rsquo;t inherently problematic, but it can be a real buzz kill when the goal is interpreting predictor importance in explanatory models. In the presence of highly correlated predictors, most modelling methods, from the veteran linear models to the fancy gradient boosting, attribute a large part of the importance to only one of the predictors and not the others. In such cases, neglecting multicollinearity will certainly lead to underestimate the relevance of certain predictors.&lt;/p&gt;
&lt;p&gt;Let me go ahead and develop a toy data set to showcase this issue. But let&amp;rsquo;s load the required libraries first.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#load the collinear package and its example data
library(collinear)
data(vi)

#other required libraries
library(ranger)
library(dplyr)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the &lt;code&gt;vi&lt;/code&gt; data frame shipped with the 
&lt;a href=&#34;https://blasbenito.github.io/collinear/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;collinear&lt;/code&gt;&lt;/a&gt; package, the variables &amp;ldquo;soil_clay&amp;rdquo; and &amp;ldquo;humidity_range&amp;rdquo; are not correlated at all (Pearson correlation = -0.06).&lt;/p&gt;
&lt;p&gt;In the code block below, the &lt;code&gt;dplyr::transmute()&lt;/code&gt; command selects and renames them as &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. After that, the two variables are scaled and centered, and &lt;code&gt;dplyr::mutate()&lt;/code&gt; generates a few new columns:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt;: response variable resulting from a linear model where &lt;code&gt;a&lt;/code&gt; has a slope of 0.75, &lt;code&gt;b&lt;/code&gt; has a slope of 0.25, plus a bit of white noise generated with &lt;code&gt;runif()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt;: a new predictor highly correlated with &lt;code&gt;a&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt;: a new predictor resulting from a linear combination of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;set.seed(1)
df &amp;lt;- vi |&amp;gt;
  dplyr::slice_sample(n = 2000) |&amp;gt;
  dplyr::transmute(
    a = soil_clay,
    b = humidity_range
  ) |&amp;gt;
  scale() |&amp;gt;
  as.data.frame() |&amp;gt; 
  dplyr::mutate(
    y = a * 0.75 + b * 0.25 + runif(n = dplyr::n(), min = -0.5, max = 0.5),
    c = a + runif(n = dplyr::n(), min = -0.5, max = 0.5),
    d = (a + b)/2 + runif(n = dplyr::n(), min = -0.5, max = 0.5)
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Pearson correlation between all pairs of these predictors is shown below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;collinear::cor_df(
  df = df,
  predictors = c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 × 3
##   x     y     correlation
##   &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;
## 1 c     a           0.962
## 2 d     b           0.639
## 3 d     a           0.636
## 4 d     c           0.615
## 5 b     a          -0.047
## 6 c     b          -0.042
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point, we have are two groups of predictors useful to understand how multicollinearity muddles model interpretation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Predictors with &lt;strong&gt;no&lt;/strong&gt; multicollinearity: &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Predictors with multicollinearity: &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the next two sections and the &lt;em&gt;Appendix&lt;/em&gt;, I show how and why model interpretation becomes challenging when multicollinearity is high. Let&amp;rsquo;s start with linear models.&lt;/p&gt;
&lt;h3 id=&#34;linear-models&#34;&gt;Linear Models&lt;/h3&gt;
&lt;p&gt;The code below fits &lt;em&gt;multiple linear regression models&lt;/em&gt; for both groups of predictors.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#non-collinear predictors
lm_ab &amp;lt;- lm(
  formula = y ~ a + b,
  data = df
  )

#collinear predictors
lm_abcd &amp;lt;- lm(
  formula = y ~ a + b + c + d,
  data = df
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I would like you to pay attention to the estimates of the predictors &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for both models. The estimates are the slopes in the linear model, a direct indication of the effect of a predictor over the response.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;coefficients(lm_ab)[2:3] |&amp;gt; 
  round(4)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      a      b 
## 0.7477 0.2616
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;coefficients(lm_abcd)[2:5] |&amp;gt; 
  round(4)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      a      b      c      d 
## 0.7184 0.2596 0.0273 0.0039
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On one hand, the model with no multicollinearity (&lt;code&gt;lm_ab&lt;/code&gt;) achieved a pretty good solution for the coefficients of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Remember that we created &lt;code&gt;y&lt;/code&gt; as &lt;code&gt;a * 0.75 + b * 0.25&lt;/code&gt; plus some noise, and that&amp;rsquo;s exactly what the model is telling us here, so the interpretation is pretty straightforward.&lt;/p&gt;
&lt;p&gt;On the other hand, the model with multicollinearity (&lt;code&gt;lm_abcd&lt;/code&gt;) did well with &lt;code&gt;b&lt;/code&gt;, but there are a few things in there that make the interpretation harder.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The coefficient of &lt;code&gt;a&lt;/code&gt; (0.7165) is slightly smaller than the true one (0.75), which could lead us to downplay its relationship with &lt;code&gt;y&lt;/code&gt; by a tiny bit. This is kinda OK though, as long as one is not using the model&amp;rsquo;s results to build nukes in the basement.&lt;/li&gt;
&lt;li&gt;The coefficient of &lt;code&gt;c&lt;/code&gt; is so small that it could led us to believe that this predictor not important at all to explain &lt;code&gt;y&lt;/code&gt;. But we know that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are almost identical copies, so model interpretation here is being definitely muddled by multicollinearity.&lt;/li&gt;
&lt;li&gt;The coefficient of &lt;code&gt;d&lt;/code&gt; is tiny. Since &lt;code&gt;d&lt;/code&gt; results from the sum of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, we could expect this predictor to be important in explaining &lt;code&gt;y&lt;/code&gt;, but it got the shorter end of the stick in this case.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It is not that the model it&amp;rsquo;s wrong though. This behavior of the linear model results from the &lt;em&gt;QR decomposition&lt;/em&gt; (also &lt;em&gt;QR factorization&lt;/em&gt;) applied by functions like &lt;code&gt;lm()&lt;/code&gt;, &lt;code&gt;glm()&lt;/code&gt;, &lt;code&gt;glmnet::glmnet()&lt;/code&gt;, and &lt;code&gt;nlme::gls()&lt;/code&gt; to improve numerical stability and computational efficiency, and to&amp;hellip; address multicollinearity in the model predictors.&lt;/p&gt;
&lt;p&gt;The QR decomposition transforms the original predictors into a set of orthogonal predictors with no multicollinearity. This is the &lt;em&gt;Q matrix&lt;/em&gt;, created in a fashion that resembles the way in which a Principal Components Analysis generates uncorrelated components from a set of correlated variables.&lt;/p&gt;
&lt;p&gt;The code below applies QR decomposition to our multicollinear predictors, extracts the Q matrix, and shows the correlation between the new versions of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#predictors names
predictors &amp;lt;- c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;)

#QR decomposition of predictors
df.qr &amp;lt;- qr(df[, predictors])

#extract Q matrix
df.q &amp;lt;- qr.Q(df.qr)
colnames(df.q) &amp;lt;- predictors

#correlation between transformed predictors
collinear::cor_df(df = df.q)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 × 3
##   x     y     correlation
##   &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;
## 1 d     c               0
## 2 c     b               0
## 3 d     b               0
## 4 d     a               0
## 5 c     a               0
## 6 b     a               0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The new set of predictors we are left with after the QR decomposition have exactly zero correlation! And now they are not our original predictors anymore, and have a different interpretation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; is now &amp;ldquo;the part of &lt;code&gt;a&lt;/code&gt; not in &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; is now &amp;ldquo;the part of &lt;code&gt;b&lt;/code&gt; not in &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;&amp;hellip;and so on&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The result of the QR decomposition can be plugged into the &lt;code&gt;solve()&lt;/code&gt; function along with the response vector to estimate the coefficients of the linear model.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;solve(a = df.qr, b = df$y) |&amp;gt; 
  round(4)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      a      b      c      d 
## 0.7189 0.2595 0.0268 0.0040
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These are almost exactly the ones we got for our model with multicollinearity. In the end, the coefficients resulting from a linear model are not those of the original predictors, but the ones of their uncorrelated versions generated by the QR decomposition.&lt;/p&gt;
&lt;p&gt;But this is not the only issue of model interpretability under multicollinearity. Let&amp;rsquo;s take a look at the standard errors of the estimates. These are a measure of the coefficient estimation uncertainty, and are used to compute the p-values of the estimates. As such, they are directly linked with the &amp;ldquo;statistical significance&amp;rdquo; (whatever that means) of the predictors within the model.&lt;/p&gt;
&lt;p&gt;The code below shows the standard errors of the model without and with multicollinearity.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;summary(lm_ab)$coefficients[, &amp;quot;Std. Error&amp;quot;][2:3] |&amp;gt; 
  round(4)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      a      b 
## 0.0066 0.0066
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;summary(lm_abcd)$coefficients[, &amp;quot;Std. Error&amp;quot;][2:5] |&amp;gt; 
  round(4)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      a      b      c      d 
## 0.0267 0.0134 0.0232 0.0230
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These standard errors of the model with multicollinearity are an order of magnitude higher than the ones of the model without multicollinearity.&lt;/p&gt;
&lt;p&gt;Since our toy dataset is relatively large (2000 cases) and the relationship between the response and a few of the predictors pretty robust, there are no real issues arising, as these differences in estimation precision are not enough to change the p-values of the estimates. However, in a small data set with high multicollinearity and a weaker relationship between the response and the predictors, standard errors of the estimate become wide, which increases p-values and reduces &amp;ldquo;significance&amp;rdquo;. Such a situation might lead us to believe that a predictor does not explain the response, when in fact it does. And this, again, is a model interpretability issue caused by multicollinearity.&lt;/p&gt;
&lt;p&gt;At the end of this post there is an appendix with code examples of other types of linear models that use QR decomposition and become challenging to interpret in the presence of multicollinearity. Play with them as you please!&lt;/p&gt;
&lt;p&gt;Now, let&amp;rsquo;s take a look at how multicollinearity can also mess up the interpretation of a commonly used machine learning algorithm.&lt;/p&gt;
&lt;h3 id=&#34;random-forest&#34;&gt;Random Forest&lt;/h3&gt;
&lt;p&gt;It is not uncommon to hear something like &amp;ldquo;random forest is insensitive to multicollinearity&amp;rdquo;. Actually, I cannot confirm nor deny that I have said that before. Anyway, it is kind of true if one is focused on prediction problmes. However, when the aim is interpreting predictor importance scores, then one has to be mindful about multicollinearity as well.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s see an example. The code below fits two random forest models with our two sets of predictors.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#non-collinear predictors
rf_ab &amp;lt;- ranger::ranger(
  formula = y ~ a + b,
  data = df,
  importance = &amp;quot;permutation&amp;quot;,
  seed = 1 #for reproducibility
)

#collinear predictors
rf_abcd &amp;lt;- ranger::ranger(
  formula = y ~ a + b + c + d,
  data = df,
  importance = &amp;quot;permutation&amp;quot;,
  seed = 1
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;rsquo;s take a look at the prediction error the two models on the out-of-bag data. While building each regression tree, Random Forest leaves a random subset of the data out. Then, each case gets a prediction from all trees that had it in the out-of-bag data, and the prediction error is averaged across all cases to get the numbers below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;rf_ab$prediction.error
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.1026779
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;rf_abcd$prediction.error
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.1035678
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;According to these numbers, these two models are basically equivalent in their ability to predict our response &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But now, you noticed that I set the argument &lt;code&gt;importance&lt;/code&gt; to &amp;ldquo;permutation&amp;rdquo;. Permutation importance quantifies how the out-of-bag error increases when a predictor is permuted across all trees where the predictor is used. It is pretty robust importance metric that bears no resemblance whatsoever with the coefficients of a linear model. Think of it as a very different way to answer the question &amp;ldquo;what variables are important in this model?&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;The permutation importance scores of the two random forest models are show below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;rf_ab$variable.importance |&amp;gt; round(4)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      a      b 
## 1.0702 0.1322
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;rf_abcd$variable.importance |&amp;gt; round(4)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      a      b      c      d 
## 0.5019 0.0561 0.1662 0.0815
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is one interesting detail here. The predictor &lt;code&gt;a&lt;/code&gt; has a permutation error three times higher than &lt;code&gt;c&lt;/code&gt; in the second model, even though we could expect them to be similar due to their very high correlation. There are two reasons for this mismatch:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Random Forest is much more sensitive to the white noise in &lt;code&gt;c&lt;/code&gt; than linear models, especially in the deep parts of the regression trees, due to local (within-split data) decoupling with the response &lt;code&gt;y&lt;/code&gt;. In consequence, it does not get selected as often as &lt;code&gt;a&lt;/code&gt; in these deeper areas of the trees, and has less overall importance.&lt;/li&gt;
&lt;li&gt;The predictor &lt;code&gt;c&lt;/code&gt; competes with &lt;code&gt;d&lt;/code&gt;, that has around 50% of the information in &lt;code&gt;c&lt;/code&gt; (and &lt;code&gt;a&lt;/code&gt;). If we remove &lt;code&gt;d&lt;/code&gt; from the model, then the permutation importance of &lt;code&gt;c&lt;/code&gt; doubles up. Then, with &lt;code&gt;d&lt;/code&gt; in the model, we underestimate the real importance of &lt;code&gt;c&lt;/code&gt; due to multicollinearity alone.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;rf_abc &amp;lt;- ranger::ranger(
  formula = y ~ a + b + c,
  data = df,
  importance = &amp;quot;permutation&amp;quot;,
  seed = 1
)
rf_abc$variable.importance |&amp;gt; round(4)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      a      b      c 
## 0.5037 0.1234 0.3133
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With all that in mind, we can conclude that interpreting importance scores in Random Forest models is challenging when multicollinearity is high. But Random Forest is not the only machine learning affected by this issue. In the Appendix below I have left an example with Extreme Gradient Boosting so you can play with it.&lt;/p&gt;
&lt;p&gt;And that&amp;rsquo;s all for now, folks, I hope you found this post useful!&lt;/p&gt;
&lt;h1 id=&#34;appendix&#34;&gt;Appendix&lt;/h1&gt;
&lt;p&gt;This section shows several extra examples of linear and machine learning models you can play with.&lt;/p&gt;
&lt;h2 id=&#34;other-linear-models-using-qr-decomposition&#34;&gt;Other linear models using QR decomposition&lt;/h2&gt;
&lt;p&gt;As I commented above, many linear modeling functions use QR decomposition, and you will have to be careful interpreting model coefficients in the presence of strong multicollinearity in the predictors.&lt;/p&gt;
&lt;p&gt;Here I show several examples with &lt;code&gt;glm()&lt;/code&gt; (Generalized Linear Models), &lt;code&gt;nlme::gls()&lt;/code&gt; (Generalized Least Squares), and &lt;code&gt;glmnet::cv.glmnet()&lt;/code&gt; (Elastic Net Regularization). In all them, no matter how fancy, the interpretation of coefficients becomes tricky when multicollinearity is high.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Generalized Linear Models with glm()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#Generalized Linear Models
#non-collinear predictors
glm_ab &amp;lt;- glm(
  formula = y ~ a + b,
  data = df
  )

round(coefficients(glm_ab), 4)[2:3]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      a      b 
## 0.7477 0.2616
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#collinear predictors
glm_abcd &amp;lt;- glm(
  formula = y ~ a + b + c + d,
  data = df
  )

round(coefficients(glm_abcd), 4)[2:5]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      a      b      c      d 
## 0.7184 0.2596 0.0273 0.0039
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Generalized Least Squares with nlme::gls()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(nlme)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &#39;nlme&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from &#39;package:dplyr&#39;:
## 
##     collapse
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#Generalized Least Squares
#non-collinear predictors
gls_ab &amp;lt;- nlme::gls(
  model = y ~ a + b,
  data = df
  )

round(coefficients(gls_ab), 4)[2:3]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      a      b 
## 0.7477 0.2616
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#collinear predictors
gls_abcd &amp;lt;- nlme::gls(
  model = y ~ a + b + c + d,
  data = df
  )

round(coefficients(gls_abcd), 4)[2:5]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      a      b      c      d 
## 0.7184 0.2596 0.0273 0.0039
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Elastic Net Regularization and Lasso penalty with glmnet::glmnet()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(glmnet)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: Matrix
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loaded glmnet 4.1-8
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#Elastic net regularization with Lasso penalty
#non-collinear predictors
glmnet_ab &amp;lt;- glmnet::cv.glmnet(
  x = as.matrix(df[, c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)]),
  y = df$y,
  alpha = 1 #lasso penalty
)

round(coef(glmnet_ab$glmnet.fit, s = glmnet_ab$lambda.min), 4)[2:3]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.7438 0.2578
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#collinear predictors
glmnet_abcd &amp;lt;- glmnet::cv.glmnet(
  x = as.matrix(df[, c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;)]),
  y = df$y,
  alpha = 1 
)

#notice that the lasso regularization nuked the coefficients of predictors b and c
round(coef(glmnet_abcd$glmnet.fit, s = glmnet_abcd$lambda.min), 4)[2:5]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.7101 0.2507 0.0267 0.0149
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;extreme-gradient-boosting-under-multicollinearity&#34;&gt;Extreme Gradient Boosting under multicollinearity&lt;/h2&gt;
&lt;p&gt;Gradient Boosting models trained with multicollinear predictors behave in a way similar to linear models with QR decomposition. When two variables are highly correlated, one of them is going to have an importance much higher than the other.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(xgboost)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &#39;xgboost&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from &#39;package:dplyr&#39;:
## 
##     slice
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#without multicollinearity
gb_ab &amp;lt;- xgboost::xgboost(
  data = as.matrix(df[, c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)]),
  label = df$y,
  objective = &amp;quot;reg:squarederror&amp;quot;,
  nrounds = 100,
  verbose = FALSE
  )

#with multicollinearity
gb_abcd &amp;lt;- xgboost::xgboost(
  data = as.matrix(df[, c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;)]),
  label = df$y,
  objective = &amp;quot;reg:squarederror&amp;quot;,
  nrounds = 100,
  verbose = FALSE
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;xgb.importance(model = gb_ab)[, c(1:2)]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Feature      Gain
## 1:       a 0.8463005
## 2:       b 0.1536995
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;xgb.importance(model = gb_abcd)[, c(1:2)] |&amp;gt; 
  dplyr::arrange(Feature)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Feature       Gain
## 1:       a 0.78129661
## 2:       b 0.07386393
## 3:       c 0.03595619
## 4:       d 0.10888327
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But there is a twist too. When two variables are perfectly correlated, one of them is removed right away from the model!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#replace c with perfect copy of a
df$c &amp;lt;- df$a

#with multicollinearity
gb_abcd &amp;lt;- xgboost::xgboost(
  data = as.matrix(df[, c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;)]),
  label = df$y,
  objective = &amp;quot;reg:squarederror&amp;quot;,
  nrounds = 100,
  verbose = FALSE
)

xgb.importance(model = gb_abcd)[, c(1:2)] |&amp;gt; 
  dplyr::arrange(Feature)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Feature       Gain
## 1:       a 0.79469959
## 2:       b 0.07857141
## 3:       d 0.12672900
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>R package `spatialRF`</title>
      <link>https://blasbenito.com/project/post-title/</link>
      <pubDate>Tue, 26 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://blasbenito.com/project/post-title/</guid>
      <description>&lt;script src=&#34;https://blasbenito.com/project/post-title/index_files/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://blasbenito.com/project/post-title/index_files/lightable/lightable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://blasbenito.com/project/post-title/index_files/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://blasbenito.com/project/post-title/index_files/lightable/lightable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://blasbenito.com/project/post-title/index_files/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://blasbenito.com/project/post-title/index_files/lightable/lightable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://blasbenito.com/project/post-title/index_files/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://blasbenito.com/project/post-title/index_files/lightable/lightable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://blasbenito.com/project/post-title/index_files/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://blasbenito.com/project/post-title/index_files/lightable/lightable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://blasbenito.com/project/post-title/index_files/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://blasbenito.com/project/post-title/index_files/lightable/lightable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://blasbenito.com/project/post-title/index_files/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://blasbenito.com/project/post-title/index_files/lightable/lightable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://blasbenito.com/project/post-title/index_files/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://blasbenito.com/project/post-title/index_files/lightable/lightable.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;!---
[![R-CMD-check](https://github.com/BlasBenito/spatialRF/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/BlasBenito/spatialRF/actions/workflows/R-CMD-check.yaml)
--&gt;
&lt;!-- badges: start --&gt;
&lt;p&gt;
&lt;a href=&#34;https://cran.r-project.org/package=spatialRF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version/spatialRF&#34; alt=&#34;CRAN status&#34;&gt;&lt;/a&gt;

&lt;a href=&#34;https://CRAN.R-project.org/package=spatialRF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;http://cranlogs.r-pkg.org/badges/grand-total/spatialRF&#34; alt=&#34;CRAN\_Download\_Badge&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;!-- badges: end --&gt;
&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The package &lt;strong&gt;spatialRF&lt;/strong&gt; facilitates fitting spatial regression models on regular or irregular data with Random Forest. It does so by generating &lt;em&gt;spatial predictors&lt;/em&gt; that help the model &amp;ldquo;understand&amp;rdquo; the spatial structure of the training data with the end goal of minimizing the spatial autocorrelation of the model residuals and offering honest variable importance scores.&lt;/p&gt;
&lt;p&gt;Two main methods to generate &lt;em&gt;spatial predictors&lt;/em&gt; from the distance matrix of the data points are implemented in the package:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Moran&amp;rsquo;s Eigenvector Maps 
&lt;a href=&#34;https://www.sciencedirect.com/science/article/abs/pii/S0304380006000925&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;(Dray, Legendre, and Peres-Neto 2006)&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Distance matrix columns as explanatory variables 
&lt;a href=&#34;https://peerj.com/articles/5518/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;(Hengl et al. 2018)&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The package is designed to minimize the code required to fit a spatial model from a training dataset, the names of the response and the predictors, and a distance matrix, as shown below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatial.model &amp;lt;- spatialRF::rf_spatial(
  data = your_dataframe,
  dependent.variable.name = &amp;quot;your_response_variable&amp;quot;,
  predictor.variable.names = c(&amp;quot;predictor1&amp;quot;, &amp;quot;predictor2&amp;quot;, ..., &amp;quot;predictorN&amp;quot;),
  distance.matrix = your_distance_matrix
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;spatialRF&lt;/strong&gt; uses the fast and efficient &lt;code&gt;ranger&lt;/code&gt; package under the hood 
&lt;a href=&#34;https://arxiv.org/abs/1508.04409&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;(Wright and Ziegler 2017)&lt;/a&gt;, so please, cite the &lt;code&gt;ranger&lt;/code&gt; package when using &lt;code&gt;spatialRF&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;This package also provides tools to identify potentially interesting variable interactions, tune random forest hyperparameters, assess model performance on spatially independent data folds, and examine the resulting models via importance plots, response curves, and response surfaces.&lt;/p&gt;
&lt;h1 id=&#34;development&#34;&gt;Development&lt;/h1&gt;
&lt;p&gt;This package is reaching its final form, and big changes are not expected at this stage. However, it has many functions, and even though all them have been tested, only one dataset has been used for those tests. You will find bugs, and something will go wrong almost surely. If you have time to report bugs, please, do so in any of the following ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Open a new issue in the 
&lt;a href=&#34;https://github.com/BlasBenito/spatialRF/issues&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Issues GitHub page of the package&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Send me an email explaining the issue and the error messages with enough detail at blasbenito at gmail dot com.&lt;/li&gt;
&lt;li&gt;Send a direct message to 
&lt;a href=&#34;https://twitter.com/blasbenito&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;my twitter account&lt;/a&gt; explaining the issue.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will do my best to solve any issues ASAP!&lt;/p&gt;
&lt;h1 id=&#34;applications&#34;&gt;Applications&lt;/h1&gt;
&lt;p&gt;The goal of &lt;code&gt;spatialRF&lt;/code&gt; is to help fitting &lt;em&gt;explanatory spatial regression&lt;/em&gt;, where the target is to understand how a set of predictors and the spatial structure of the data influences response variable. Therefore, the spatial analyses implemented in the package can be applied to any spatial dataset, regular or irregular, with a sample size between ~100 and ~5000 cases (the higher end will depend on the RAM memory available), a quantitative or binary (values 0 and 1) response variable, and a more or less large set of predictive variables.&lt;/p&gt;
&lt;p&gt;All functions but &lt;code&gt;rf_spatial()&lt;/code&gt; work with non-spatial data as well if the arguments &lt;code&gt;distance.matrix&lt;/code&gt; and &lt;code&gt;distance.thresholds&lt;/code&gt; are not provided In such case, the number of training cases is no longer limited by the size of the distance matrix, and models can be trained with hundreds of thousands of rows. In such case, the spatial autocorrelation of the model&amp;rsquo;s residuals is not assessed.&lt;/p&gt;
&lt;p&gt;However, &lt;strong&gt;when the focus is on fitting spatial models&lt;/strong&gt;, and due to the nature of the &lt;em&gt;spatial predictors&lt;/em&gt; used to represent the spatial structure of the training data, &lt;strong&gt;there are many things this package cannot do&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Predict model results over raster data.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Predict a model result over another region with a different spatial structure.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Work with &amp;ldquo;big data&amp;rdquo;, whatever that means.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Imputation or extrapolation (it can be done, but models based on spatial predictors are hardly transferable).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Take temporal autocorrelation into account (but this is something that might be implemented later on).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If after considering these limitations you are still interested, follow me, I will show you how it works.&lt;/p&gt;
&lt;h1 id=&#34;citation&#34;&gt;Citation&lt;/h1&gt;
&lt;p&gt;There is a paper in the making about this package. In the meantime, if you find it useful for your academic work, please cite the &lt;code&gt;ranger&lt;/code&gt; package as well, it is the true core of &lt;code&gt;spatialRF&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Marvin N. Wright, Andreas Ziegler (2017). ranger: A Fast Implementation of Random Forests for High Dimensional Data in C++ and R. Journal of Statistical Software, 77(1), 1-17. doi:10.18637/jss.v077.i01&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Blas M. Benito (2021). spatialRF: Easy Spatial Regression with Random Forest. R package version 1.1.0. doi: 10.5281/zenodo.4745208. url: 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blasbenito.github.io/spatialRF/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;install&#34;&gt;Install&lt;/h1&gt;
&lt;p&gt;The version 1.1.3 can be installed from CRAN:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;install.packages(&amp;quot;spatialRF&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The package can also be installed from GitHub as follows. There are several branches in the repository:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;: latest stable version (1.1.0 currently).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;development&lt;/code&gt;: development version, usually very broken.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v.1.0.9&lt;/code&gt; to &lt;code&gt;v.1.1.2&lt;/code&gt;: archived versions.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;remotes::install_github(
  repo = &amp;quot;blasbenito/spatialRF&amp;quot;, 
  ref = &amp;quot;main&amp;quot;,
  force = TRUE,
  quiet = TRUE
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a few other libraries that will be useful during this tutorial.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(spatialRF)
library(kableExtra)
library(rnaturalearth)
library(rnaturalearthdata)
library(tidyverse)
library(randomForestExplainer)
library(pdp)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;data-requirements&#34;&gt;Data requirements&lt;/h1&gt;
&lt;p&gt;The data required to fit random forest models with &lt;code&gt;spatialRF&lt;/code&gt; must fulfill several conditions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The input format is data.frame&lt;/strong&gt;. At the moment, tibbles are not fully supported.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The number of rows must be somewhere between 100 and ~5000&lt;/strong&gt;, at least if your target is fitting spatial models. This limitation comes from the fact that the distance matrix grows very fast with an increasing number of training records, so for large datasets, there might not be enough RAM in your machine.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The number of predictors should be larger than 3&lt;/strong&gt;. Fitting a Random Forest model is moot otherwise.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Factors in the response or the predictors are not explicitly supported in the package&lt;/strong&gt;. They may work, or they won&amp;rsquo;t, but in any case, I designed this package for quantitative data alone. However, binary responses with values 0 and 1 are partially supported.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Must be free of &lt;code&gt;NA&lt;/code&gt;&lt;/strong&gt;. You can check if there are NA records with &lt;code&gt;sum(apply(df, 2, is.na))&lt;/code&gt;. If the result is larger than 0, then just execute &lt;code&gt;df &amp;lt;- na.omit(df)&lt;/code&gt; to remove rows with empty cells.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Columns cannot have zero variance&lt;/strong&gt;. This condition can be checked with &lt;code&gt;apply(df, 2, var) == 0&lt;/code&gt;. Columns yielding TRUE should be removed.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Columns must not yield &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Inf&lt;/code&gt; when scaled&lt;/strong&gt;. You can check each condition with &lt;code&gt;sum(apply(scale(df), 2, is.nan))&lt;/code&gt; and &lt;code&gt;sum(apply(scale(df), 2, is.infinite))&lt;/code&gt;. If higher than 0, you can find what columns are giving issues with &lt;code&gt;sapply(as.data.frame(scale(df)), function(x)any(is.nan(x)))&lt;/code&gt; and &lt;code&gt;sapply(as.data.frame(scale(df)), function(x)any(is.infinite(x)))&lt;/code&gt;. Any column yielding &lt;code&gt;TRUE&lt;/code&gt; will generate issues while trying to fit models with &lt;code&gt;spatialRF&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;example-data&#34;&gt;Example data&lt;/h1&gt;
&lt;p&gt;The package includes an example dataset that fulfills the conditions mentioned above, named 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plant_richness_df.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;plant_richness_df&lt;/code&gt;&lt;/a&gt;. It is a data frame with plant species richness and predictors for 227 ecoregions in the Americas, and a distance matrix among the ecoregion edges named, well, 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/distance_matrix.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;distance_matrix&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The package follows a convention throughout functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The argument &lt;code&gt;data&lt;/code&gt; requires a training data frame.&lt;/li&gt;
&lt;li&gt;The argument &lt;code&gt;dependent.variable.name&lt;/code&gt; is the column name of the response variable.&lt;/li&gt;
&lt;li&gt;The argument &lt;code&gt;predictor.variable.names&lt;/code&gt; contains the column names of the predictors.&lt;/li&gt;
&lt;li&gt;The argument &lt;code&gt;xy&lt;/code&gt; takes a data frame or matrix with two columns named &amp;ldquo;x&amp;rdquo; and &amp;ldquo;y&amp;rdquo;, in that order, with the case coordinates.&lt;/li&gt;
&lt;li&gt;The argument &lt;code&gt;distance.matrix&lt;/code&gt; requires a matrix of distances between the cases in &lt;code&gt;data&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The argument &lt;code&gt;distance.thresholds&lt;/code&gt; is a numeric vector of distances at with spatial autocorrelation wants to be computed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It is convenient to define these arguments at the beginning of the workflow.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#loading training data and distance matrix from the package
data(plant_richness_df)
data(distance_matrix)

#names of the response variable and the predictors
dependent.variable.name &amp;lt;- &amp;quot;richness_species_vascular&amp;quot;
predictor.variable.names &amp;lt;- colnames(plant_richness_df)[5:21]

#coordinates of the cases
xy &amp;lt;- plant_richness_df[, c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;)]

#distance matrix
distance.matrix &amp;lt;- distance_matrix

#distance thresholds (same units as distance_matrix)
distance.thresholds &amp;lt;- c(0, 1000, 2000, 4000, 8000)

#random seed for reproducibility
random.seed &amp;lt;- 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The response variable of &lt;code&gt;plant_richness_df&lt;/code&gt; is &amp;ldquo;richness_species_vascular&amp;rdquo;, that represents the total count of vascular plant species found on each ecoregion. The figure below shows the centroids of each ecoregion along with their associated value of the response variable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;world &amp;lt;- rnaturalearth::ne_countries(
  scale = &amp;quot;medium&amp;quot;, 
  returnclass = &amp;quot;sf&amp;quot;
  )

ggplot2::ggplot() +
  ggplot2::geom_sf(
    data = world, 
    fill = &amp;quot;white&amp;quot;
    ) +
  ggplot2::geom_point(
    data = plant_richness_df,
    ggplot2::aes(
      x = x,
      y = y,
      color = richness_species_vascular
    ),
    size = 2.5
  ) +
  ggplot2::scale_color_viridis_c(
    direction = -1, 
    option = &amp;quot;F&amp;quot;
    ) +
  ggplot2::theme_bw() +
  ggplot2::labs(color = &amp;quot;Plant richness&amp;quot;) +
  ggplot2::scale_x_continuous(limits = c(-170, -30)) +
  ggplot2::scale_y_continuous(limits = c(-58, 80))  +
  ggplot2::ggtitle(&amp;quot;Plant richness of the American ecoregions&amp;quot;) + 
  ggplot2::xlab(&amp;quot;Longitude&amp;quot;) + 
  ggplot2::ylab(&amp;quot;Latitude&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;576&#34; /&gt;
&lt;p&gt;The predictors (columns 5 to 21) represent diverse factors that may influence plant richness such as sampling bias, the area of the ecoregion, climatic variables, human presence and impact, topography, geographical fragmentation, and features of the neighbors of each ecoregion. The figure below shows the scatterplots of the response variable (y axis) against each predictor (x axis).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Every plotting function in the package now allows changing the colors of their main features via specific arguments such as &lt;code&gt;point.color&lt;/code&gt;, &lt;code&gt;line.color&lt;/code&gt;, or &lt;code&gt;fill.color&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::plot_training_df(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  ncol = 3,
  point.color = viridis::viridis(100, option = &amp;quot;F&amp;quot;),
  line.color = &amp;quot;gray30&amp;quot;
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;960&#34; /&gt;
&lt;p&gt;The function 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plot_training_df_moran.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;plot_training_df_moran()&lt;/code&gt;&lt;/a&gt; helps assessing the spatial autocorrelation of the response variable and the predictors across different distance thresholds. Low Moran&amp;rsquo;s I and p-values equal or larger than 0.05 indicate that there is no spatial autocorrelation for the given variable and distance threshold.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::plot_training_df_moran(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance.matrix,
  distance.thresholds = distance.thresholds,
  fill.color = viridis::viridis(
    100,
    option = &amp;quot;F&amp;quot;,
    direction = -1
    ),
  point.color = &amp;quot;gray40&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;768&#34; /&gt;
&lt;h1 id=&#34;reducing-multicollinearity-in-the-predictors&#34;&gt;Reducing multicollinearity in the predictors&lt;/h1&gt;
&lt;p&gt;The functions 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/auto_cor.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;auto_cor()&lt;/code&gt;&lt;/a&gt; and 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/auto_vif.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;auto_vif()&lt;/code&gt;&lt;/a&gt; help reduce redundancy in the predictors by using different criteria (bivariate R squared vs. 
&lt;a href=&#34;https://www.statisticshowto.com/variance-inflation-factor/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;variance inflation factor&lt;/a&gt;), while allowing the user to define an &lt;em&gt;order of preference&lt;/em&gt;, which can be based either on domain expertise or on a quantitative assessment (e.g., order of preference based on variable importance scores or model coefficients). The preference order is defined as a character vector in the &lt;code&gt;preference.order&lt;/code&gt; argument of both functions, and does not need to include the names of all predictors, but just the ones the user would like to keep in the analysis.&lt;/p&gt;
&lt;p&gt;Notice that I have set &lt;code&gt;cor.threshold&lt;/code&gt; and &lt;code&gt;vif.threshold&lt;/code&gt; to low values because the predictors in &lt;code&gt;plant_richness_df&lt;/code&gt; already have little multicollinearity,. The default values (&lt;code&gt;cor.threshold = 0.75&lt;/code&gt; and &lt;code&gt;vif.threshold = 5&lt;/code&gt;) should work well when combined together for any other set of predictors.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;preference.order &amp;lt;- c(
    &amp;quot;climate_bio1_average_X_bias_area_km2&amp;quot;,
    &amp;quot;climate_aridity_index_average&amp;quot;,
    &amp;quot;climate_hypervolume&amp;quot;,
    &amp;quot;climate_bio1_average&amp;quot;,
    &amp;quot;climate_bio15_minimum&amp;quot;,
    &amp;quot;bias_area_km2&amp;quot;
  )

predictor.variable.names &amp;lt;- spatialRF::auto_cor(
  x = plant_richness_df[, predictor.variable.names],
  cor.threshold = 0.6,
  preference.order = preference.order
) %&amp;gt;% 
  spatialRF::auto_vif(
    vif.threshold = 2.5,
    preference.order = preference.order
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [auto_cor()]: Removed variables: human_footprint_average
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [auto_vif()]: Variables are not collinear.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of &lt;code&gt;auto_cor()&lt;/code&gt; or &lt;code&gt;auto_vif()&lt;/code&gt; has the class &amp;ldquo;variable_selection&amp;rdquo;, which can be used as input in every function having the argument &lt;code&gt;predictor.variable.names&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;names(predictor.variable.names)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;vif&amp;quot;                   &amp;quot;selected.variables&amp;quot;    &amp;quot;selected.variables.df&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The slot &lt;code&gt;selected.variables&lt;/code&gt; contains the names of the selected predictors.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;predictor.variable.names$selected.variables
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;climate_aridity_index_average&amp;quot;   &amp;quot;climate_hypervolume&amp;quot;            
##  [3] &amp;quot;climate_bio1_average&amp;quot;            &amp;quot;climate_bio15_minimum&amp;quot;          
##  [5] &amp;quot;bias_area_km2&amp;quot;                   &amp;quot;bias_species_per_record&amp;quot;        
##  [7] &amp;quot;climate_velocity_lgm_average&amp;quot;    &amp;quot;neighbors_count&amp;quot;                
##  [9] &amp;quot;neighbors_percent_shared_edge&amp;quot;   &amp;quot;human_population_density&amp;quot;       
## [11] &amp;quot;topography_elevation_average&amp;quot;    &amp;quot;landcover_herbs_percent_average&amp;quot;
## [13] &amp;quot;fragmentation_cohesion&amp;quot;          &amp;quot;fragmentation_division&amp;quot;         
## [15] &amp;quot;neighbors_area&amp;quot;                  &amp;quot;human_population&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;finding-promising-variable-interactions&#34;&gt;Finding promising variable interactions&lt;/h1&gt;
&lt;p&gt;Random Forests already takes into account variable interactions of the form &amp;ldquo;variable &lt;code&gt;a&lt;/code&gt; becomes important when &lt;code&gt;b&lt;/code&gt; is higher than x&amp;rdquo;. However, Random Forest can also take advantage of variable interactions of the form &lt;code&gt;a * b&lt;/code&gt;, across the complete ranges of the predictors, as they are commonly defined in regression models, and &amp;ldquo;interactions&amp;rdquo; (not the proper name, but used here for simplicity) represented by the first component of a PCA on the predictors &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The function 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/the_feature_engineer.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;the_feature_engineer()&lt;/code&gt;&lt;/a&gt; tests all possible interactions of both types among the most important predictors, and suggesting the ones not correlated among themselves and with the other predictors inducing an increase in the model&amp;rsquo;s R squared (or AUC when the response is binary) on independent data via spatial cross-validation (see &lt;code&gt;rf_evaluate()&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;interactions &amp;lt;- spatialRF::the_feature_engineer(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  xy = xy,
  importance.threshold = 0.50, #uses 50% best predictors
  cor.threshold = 0.60, #max corr between interactions and predictors
  seed = random.seed,
  repetitions = 100,
  verbose = TRUE
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Fitting and evaluating a model without interactions.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Testing 28 candidate interactions.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Interactions identified: 5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  ┌──────────────────┬──────────────────┬──────────────────┬──────────────────┐
##  │ Interaction      │ Importance (% of │        R-squared │     Max cor with │
##  │                  │             max) │      improvement │       predictors │
##  ├──────────────────┼──────────────────┼──────────────────┼──────────────────┤
##  │ bias_area_km2..x │             60.8 │            0.096 │            0.60  │
##  │ ..bias_species_p │                  │                  │                  │
##  │ er_record        │                  │                  │                  │
##  ├──────────────────┼──────────────────┼──────────────────┼──────────────────┤
##  │ climate_bio1_ave │             97.9 │            0.067 │            0.34  │
##  │ rage..pca..human │                  │                  │                  │
##  │ _population_dens │                  │                  │                  │
##  │ ity              │                  │                  │                  │
##  ├──────────────────┼──────────────────┼──────────────────┼──────────────────┤
##  │ climate_bio1_ave │             98.7 │            0.049 │            0.24  │
##  │ rage..pca..neigh │                  │                  │                  │
##  │ bors_count       │                  │                  │                  │
##  ├──────────────────┼──────────────────┼──────────────────┼──────────────────┤
##  │ human_population │             66.5 │            0.021 │            0.55  │
##  │ ..x..bias_specie │                  │                  │                  │
##  │ s_per_record     │                  │                  │                  │
##  ├──────────────────┼──────────────────┼──────────────────┼──────────────────┤
##  │ bias_area_km2..p │             62.7 │            0.029 │            0.305 │
##  │ ca..neighbors_pe │                  │                  │                  │
##  │ rcent_shared_edg │                  │                  │                  │
##  │ e                │                  │                  │                  │
##  └──────────────────┴──────────────────┴──────────────────┴──────────────────┘
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Comparing models with and without interactions via spatial cross-validation.
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-12-1.png&#34; width=&#34;1248&#34; /&gt;
&lt;p&gt;The upper panel in the plot plot above shows the relationship between the interaction and the response variable. It also indicates the gain in R squared (+R2), the importance, in percentage, when used in a model along the other predictors (Imp. (%)), and the maximum Pearson correlation of the interaction with the predictors. The violin-plot shows a comparison of the model with and without the selected interaction made via spatial cross-validation using 100 repetitions (see 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rf_evaluate.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;rf_evaluate()&lt;/code&gt;&lt;/a&gt; and 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rf_compare.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;rf_compare()&lt;/code&gt;&lt;/a&gt; for further details).&lt;/p&gt;
&lt;p&gt;The function also returns a data frame with all the interactions considered.  The columns are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;interaction.name&lt;/code&gt;: Interactions computed via multiplication are named &lt;code&gt;a..x..b&lt;/code&gt;, while interactions computed via PCA are named &lt;code&gt;a..pca..b&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;interaction.importance&lt;/code&gt;: Importance of the interaction expressed as a percentage. If &lt;code&gt;interaction.importance == 100&lt;/code&gt;, that means that the interaction is the most important predictor in the model fitted with the interaction and the predictors named in &lt;code&gt;predictor.variable.names&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;interaction.metric.gain&lt;/code&gt;: Difference in R squared (or AUC for models fitting a binary response) between a model with and a model without the interaction.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max.cor.with.predictors&lt;/code&gt;: The maximum Pearson correlation of the interaction with the predictors named in &lt;code&gt;predictor.variable.names&lt;/code&gt;. Gives an idea of the amount of multicollinearity the interaction introduces in the model.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;variable.a.name&lt;/code&gt; and &lt;code&gt;variable.b.name&lt;/code&gt;: Names of the predictors involved in the interaction.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selected&lt;/code&gt;: &lt;code&gt;TRUE&lt;/code&gt; if the interaction fulfills the selection criteria (importance higher than a threshold, positive gain in R squared or AUC, and Pearson correlation with other predictors lower than a threshold). The selected interactions have a correlation among themselves always lower than the value of the argument &lt;code&gt;cor.threshold&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;kableExtra::kbl(
  head(interactions$screening, 10),
  format = &amp;quot;html&amp;quot;
) %&amp;gt;%
  kableExtra::kable_paper(&amp;quot;hover&amp;quot;, full_width = F)
&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34; lightable-paper lightable-hover&#34; style=&#39;font-family: &#34;Arial Narrow&#34;, arial, helvetica, sans-serif; width: auto !important; margin-left: auto; margin-right: auto;&#39;&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; interaction.name &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; interaction.importance &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; interaction.metric.gain &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; max.cor.with.predictors &lt;/th&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; variable.a.name &lt;/th&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; variable.b.name &lt;/th&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; selected &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_area_km2..x..bias_species_per_record &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 60.779 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.096 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.5962899 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_area_km2 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_species_per_record &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; TRUE &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 97.944 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.067 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.3369664 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; TRUE &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..neighbors_count &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 98.742 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.049 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.2441858 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; neighbors_count &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; TRUE &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..neighbors_percent_shared_edge &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 84.196 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.066 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.2215337 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; neighbors_percent_shared_edge &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; TRUE &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; human_population..x..bias_species_per_record &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 66.512 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.021 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.5462406 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; human_population &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_species_per_record &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; TRUE &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..bias_species_per_record &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 70.082 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.018 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.3469834 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_species_per_record &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; TRUE &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_area_km2..pca..neighbors_percent_shared_edge &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 62.678 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.029 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.3046471 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_area_km2 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; neighbors_percent_shared_edge &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; TRUE &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_hypervolume..x..human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 49.367 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.006 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.5599486 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_hypervolume &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; FALSE &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; neighbors_count..pca..neighbors_percent_shared_edge &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 63.808 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.016 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.1584006 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; neighbors_count &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; neighbors_percent_shared_edge &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; TRUE &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_area_km2..pca..neighbors_count &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 58.662 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.012 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.2166191 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_area_km2 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; neighbors_count &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; TRUE &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The function returns a data frame with the response variables, the predictors, and the selected interactions that can be used right away as a training data frame. However, the function cannot say whether an interaction &lt;em&gt;makes sense&lt;/em&gt;, and it is up to the user to choose wisely whether to select an interaction or not. In this particular case, and just for the sake of simplicity, we will be using the resulting data frame as training data.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#adding interaction column to the training data
plant_richness_df &amp;lt;- interactions$data

#adding interaction name to predictor.variable.names
predictor.variable.names &amp;lt;- interactions$predictor.variable.names
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;fitting-a-non-spatial-random-forest-model-with-rf&#34;&gt;Fitting a non-spatial Random Forest model with &lt;code&gt;rf()&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;The function 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rf.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;rf()&lt;/code&gt;&lt;/a&gt; is a convenient wrapper for &lt;code&gt;ranger::ranger()&lt;/code&gt; used in every modelling function of the &lt;em&gt;spatialRF&lt;/em&gt; package. It takes the training data, the names of the response and the predictors, and optionally (to assess the spatial autocorrelation of the residuals), the distance matrix, and a vector of distance thresholds (in the same units as the distances in &lt;strong&gt;distance_matrix&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;These distance thresholds are the neighborhoods at which the model will check the spatial autocorrelation of the residuals. Their values may depend on the spatial scale of the data, and the ecological system under study.&lt;/p&gt;
&lt;p&gt;Notice that here I plug the object &lt;code&gt;predictor.variable.names&lt;/code&gt;, output of &lt;code&gt;auto_cor()&lt;/code&gt; and &lt;code&gt;auto_vif()&lt;/code&gt;, directly into the &lt;code&gt;predictor.variable.names&lt;/code&gt; argument of the &lt;code&gt;rf()&lt;/code&gt; function to fit a random forest model.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;model.non.spatial &amp;lt;- spatialRF::rf(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance.matrix,
  distance.thresholds = distance.thresholds,
  xy = xy, #not needed by rf, but other functions read it from the model
  seed = random.seed,
  verbose = FALSE
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is a list with several slots containing the information required to interpret the model. The information available in these slots can be plotted (functions named &lt;code&gt;plot_...()&lt;/code&gt;), printed to screen (&lt;code&gt;print_...()&lt;/code&gt;) and captured for further analyses (&lt;code&gt;get_...()&lt;/code&gt;).&lt;/p&gt;
&lt;h2 id=&#34;residuals&#34;&gt;Residuals&lt;/h2&gt;
&lt;p&gt;The slot &lt;strong&gt;residuals&lt;/strong&gt; (&lt;code&gt;model.non.spatial$residuals&lt;/code&gt;) stores the values of the residuals and the results of the normality and spatial autocorrelation tests, and its content can be plotted with 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plot_residuals_diagnostics.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;plot_residuals_diagnostics()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::plot_residuals_diagnostics(
  model.non.spatial,
  verbose = FALSE
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;576&#34; /&gt;
&lt;p&gt;The upper panels show the results of the normality test (interpretation in the title), the middle panel shows the relationship between the residuals and the fitted values, important to understand the behavior of the residuals, and the lower panel shows the Moran&amp;rsquo;s I of the residuals across distance thresholds and their respective p-values (positive for 0 and 1000 km).&lt;/p&gt;
&lt;h2 id=&#34;variable-importance&#34;&gt;Variable importance&lt;/h2&gt;
&lt;h3 id=&#34;global-variable-importance&#34;&gt;Global variable importance&lt;/h3&gt;
&lt;p&gt;The slot &lt;strong&gt;importance&lt;/strong&gt; (&lt;code&gt;model.non.spatial$variable.importance&lt;/code&gt;) contains the variable importance scores. These can be plotted with 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plot_importance.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;plot_importance()&lt;/code&gt;&lt;/a&gt;, printed with 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/print_importance.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;print_importance()&lt;/code&gt;&lt;/a&gt;, and the dataframe retrieved with 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/get_importance.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;get_importance()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::plot_importance(
  model.non.spatial,
  verbose = FALSE
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;576&#34; /&gt;
&lt;p&gt;Variable importance represents the increase in mean error (computed on the out-of-bag data) across trees when a predictor is permuted. Values lower than zero would indicate that the variable performs worse than a random one.&lt;/p&gt;
&lt;p&gt;If the argument &lt;code&gt;scaled.importance = TRUE&lt;/code&gt; is used, the variable importance scores are computed from the scaled data, making the importance scores easier to compare across different models.&lt;/p&gt;
&lt;p&gt;The package 
&lt;a href=&#34;https://github.com/ModelOriented/randomForestExplainer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;randomForestExplainer&lt;/code&gt;&lt;/a&gt; offers a couple of interesting options to deepen our understanding on variable importance scores. The first one is &lt;code&gt;measure_importance()&lt;/code&gt;, which analyzes the forest to find out the average minimum tree depth at which each variable can be found (&lt;code&gt;mean_min_depth&lt;/code&gt;), the number of nodes in which a variable was selected to make a split (&lt;code&gt;no_of_nodes&lt;/code&gt;), the number of times the variable was selected as the first one to start a tree (&lt;code&gt;times_a_root&lt;/code&gt;), and the probability of a variable to be in more nodes than what it would be expected by chance (&lt;code&gt;p_value&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;importance.df &amp;lt;- randomForestExplainer::measure_importance(
  model.non.spatial,
  measures = c(&amp;quot;mean_min_depth&amp;quot;, &amp;quot;no_of_nodes&amp;quot;, &amp;quot;times_a_root&amp;quot;, &amp;quot;p_value&amp;quot;)
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;kableExtra::kbl(
  importance.df %&amp;gt;% 
    dplyr::arrange(mean_min_depth) %&amp;gt;% 
    dplyr::mutate(p_value = round(p_value, 4)),
  format = &amp;quot;html&amp;quot;
) %&amp;gt;%
  kableExtra::kable_paper(&amp;quot;hover&amp;quot;, full_width = F)
&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34; lightable-paper lightable-hover&#34; style=&#39;font-family: &#34;Arial Narrow&#34;, arial, helvetica, sans-serif; width: auto !important; margin-left: auto; margin-right: auto;&#39;&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; variable &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; mean_min_depth &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; no_of_nodes &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; times_a_root &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; p_value &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..neighbors_count &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2.811087 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2098 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 86 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0000 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; human_population &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2.989940 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2222 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 51 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0000 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3.117996 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1979 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 57 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0000 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_hypervolume &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3.200133 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2072 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 44 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0000 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3.201070 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1781 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 64 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.4909 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_area_km2..x..bias_species_per_record &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3.379787 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1797 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 46 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.3406 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3.454233 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1900 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 23 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0020 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_species_per_record &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3.564676 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2321 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0000 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_area_km2..pca..neighbors_percent_shared_edge &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3.959485 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1712 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 33 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.9519 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; human_population..x..bias_species_per_record &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3.977952 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1780 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 32 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.5006 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_area_km2 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 4.186849 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1800 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 10 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.3144 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; neighbors_count &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 4.204326 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1325 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 29 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1.0000 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; topography_elevation_average &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 4.306636 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1732 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.8795 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; neighbors_percent_shared_edge &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 4.409251 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1700 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 5 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.9749 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; neighbors_area &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 4.643590 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1621 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1.0000 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; fragmentation_cohesion &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 4.770930 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1518 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 8 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1.0000 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_velocity_lgm_average &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 4.845155 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1658 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.9986 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_aridity_index_average &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 4.858302 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1682 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.9919 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; landcover_herbs_percent_average &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 4.984346 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1656 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.9988 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio15_minimum &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 5.057002 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1552 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 2 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1.0000 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; fragmentation_division &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 5.229187 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1468 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1.0000 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;contribution-of-predictors-to-model-transferability&#34;&gt;Contribution of predictors to model transferability&lt;/h3&gt;
&lt;p&gt;The new function &lt;code&gt;rf_importance()&lt;/code&gt; offers a way to assess to what extent each predictor contributes to model transferability (predictive ability on independent spatial folds measured with &lt;code&gt;rf_evaluate()&lt;/code&gt;, see below). It does so by comparing the performance of the full model with models fitted without each one of the predictors. The difference in performance between the full model and a model without a given predictor represents the contribution of such predictor to model transferability.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;model.non.spatial &amp;lt;- spatialRF::rf_importance(
  model = model.non.spatial
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-20-1.png&#34; width=&#34;768&#34; /&gt;
&lt;p&gt;The function results are added to the &amp;ldquo;importance&amp;rdquo; slot of the model.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;names(model.non.spatial$importance)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;per.variable&amp;quot;          &amp;quot;local&amp;quot;                 &amp;quot;oob.per.variable.plot&amp;quot;
## [4] &amp;quot;cv.per.variable.plot&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The data frame &amp;ldquo;per.variable&amp;rdquo; contains the columns &amp;ldquo;importance.cv&amp;rdquo; (median importance), &amp;ldquo;importance.cv.mad&amp;rdquo; (median absolute deviation), &amp;ldquo;importance.cv.percent&amp;rdquo; (median importance in percentage), and &amp;ldquo;importance.cv.percent.mad&amp;rdquo; (median absolute deviation of the importance in percent). The ggplot object &amp;ldquo;cv.per.variable.plot&amp;rdquo; contains the importance plot with the median and the median absolute deviation shown above.&lt;/p&gt;
&lt;p&gt;The importance computed by random forest on the out-of-bag data by permutating each predictor (as computed by &lt;code&gt;rf()&lt;/code&gt;) and the contribution of each predictor to model transferability (as computed by &lt;code&gt;rf_importance()&lt;/code&gt;) show a moderate correlation, indicating that both importance measures capture different aspects of the effect of the variables on the model results.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;model.non.spatial$importance$per.variable %&amp;gt;% 
  ggplot2::ggplot() +
  ggplot2::aes(
    x = importance.oob,
    y = importance.cv
  ) + 
  ggplot2::geom_point(size = 3) + 
  ggplot2::theme_bw() +
  ggplot2::xlab(&amp;quot;Importance (out-of-bag)&amp;quot;) + 
  ggplot2::ylab(&amp;quot;Contribution to transferability&amp;quot;) + 
  ggplot2::geom_smooth(method = &amp;quot;lm&amp;quot;, formula = y ~ x, color = &amp;quot;red4&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-22-1.png&#34; width=&#34;576&#34; /&gt;
&lt;h3 id=&#34;local-variable-importance&#34;&gt;Local variable importance&lt;/h3&gt;
&lt;p&gt;Random forest also computes the average increase in error when a variable is permuted for each case. This is named &amp;ldquo;local importance&amp;rdquo;, is stored in &lt;code&gt;model.non.spatial$importance$local&lt;/code&gt; as a data frame, and can be retrieved with 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/get_importance_local.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;get_importance_local()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;local.importance &amp;lt;- spatialRF::get_importance_local(model.non.spatial)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The table below shows the first few records and columns. Larger values indicate larger average errors when estimating a case with the permuted version of the variable, so more important variables will show larger values.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;kableExtra::kbl(
  round(local.importance[1:10, 1:5], 0),
  format = &amp;quot;html&amp;quot;
) %&amp;gt;%
  kableExtra::kable_paper(&amp;quot;hover&amp;quot;, full_width = F)
&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34; lightable-paper lightable-hover&#34; style=&#39;font-family: &#34;Arial Narrow&#34;, arial, helvetica, sans-serif; width: auto !important; margin-left: auto; margin-right: auto;&#39;&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; climate_aridity_index_average &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; climate_hypervolume &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; climate_bio1_average &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; climate_bio15_minimum &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; bias_area_km2 &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -120 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 705 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 214 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 231 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -274 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 502 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -400 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -431 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 375 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 470 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -182 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -155 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1152 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 46 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -75 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 384 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 769 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 704 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 5 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -538 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -399 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -706 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -669 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 350 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -711 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 248 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1113 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 715 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 483 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 475 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 195 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 705 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 513 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 286 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 332 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -247 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -629 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 506 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -332 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -125 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 335 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -519 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1016 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 95 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -246 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 275 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1154 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 429 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 71 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 234 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;When case coordinates are joined with the local importance scores, it is possible to draw maps showing how variable importance changes over space.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#adding coordinates
local.importance &amp;lt;- cbind(
  xy,
  local.importance
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#colors
color.low &amp;lt;- viridis::viridis(
    3,
    option = &amp;quot;F&amp;quot;
    )[2]
color.high &amp;lt;- viridis::viridis(
    3,
    option = &amp;quot;F&amp;quot;
    )[1]

#plot of climate_bio1_average
p1 &amp;lt;- ggplot2::ggplot() +
  ggplot2::geom_sf(
    data = world,
    fill = &amp;quot;white&amp;quot;
  ) +
  ggplot2::geom_point(
    data = local.importance,
    ggplot2::aes(
      x = x,
      y = y,
      color = climate_bio1_average
    )
  ) +
  ggplot2::scale_x_continuous(limits = c(-170, -30)) +
  ggplot2::scale_y_continuous(limits = c(-58, 80)) +
  ggplot2::scale_color_gradient2(
    low = color.low, 
    high = color.high
    ) +
  ggplot2::theme_bw() +
  ggplot2::theme(legend.position = &amp;quot;bottom&amp;quot;) + 
  ggplot2::ggtitle(&amp;quot;climate_bio1_average&amp;quot;) +
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5),
    legend.key.width = ggplot2::unit(1,&amp;quot;cm&amp;quot;)
    ) + 
  ggplot2::labs(color = &amp;quot;Importance&amp;quot;) + 
  ggplot2::xlab(&amp;quot;Longitude&amp;quot;) + 
  ggplot2::ylab(&amp;quot;Latitude&amp;quot;)

p2 &amp;lt;- ggplot2::ggplot() +
  ggplot2::geom_sf(
    data = world,
    fill = &amp;quot;white&amp;quot;
  ) +
  ggplot2::geom_point(
    data = local.importance,
    ggplot2::aes(
      x = x,
      y = y,
      color = human_population
    )
  ) +
  ggplot2::scale_x_continuous(limits = c(-170, -30)) +
  ggplot2::scale_y_continuous(limits = c(-58, 80)) +
  ggplot2::scale_color_gradient2(
    low = color.low, 
    high = color.high
    ) +
  ggplot2::theme_bw() +
  ggplot2::theme(legend.position = &amp;quot;bottom&amp;quot;) +
  ggplot2::ggtitle(&amp;quot;human_population&amp;quot;) +
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5),
    legend.key.width = ggplot2::unit(1,&amp;quot;cm&amp;quot;)
    ) + 
  ggplot2::labs(color = &amp;quot;Importance&amp;quot;) + 
  ggplot2::xlab(&amp;quot;Longitude&amp;quot;) + 
  ggplot2::ylab(&amp;quot;Latitude&amp;quot;)

p1 + p2
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-26-1.png&#34; width=&#34;768&#34; /&gt;
&lt;p&gt;In these maps, values lower than 0 indicate that for a given record, the permuted version of the variable led to an accuracy score even higher than the one of the non-permuted variable, so again these negative values can be interpreted as &amp;ldquo;worse than chance&amp;rdquo;.&lt;/p&gt;
&lt;h2 id=&#34;response-curves-and-surfaces&#34;&gt;Response curves and surfaces&lt;/h2&gt;
&lt;p&gt;The variable importance scores are also used by the function 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plot_response_curves.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;plot_response_curves()&lt;/code&gt;&lt;/a&gt; to plot partial dependence curves for the predictors (by default, only the ones with an importance score above the median). Building the partial dependency curve of a predictor requires setting the other predictors to their quantiles (0.1, 0.5, and 0.9 by default). This helps to understand how the response curve of a variable changes when all the other variables have low, centered, or high values. The function also allows to see the training data&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::plot_response_curves(
  model.non.spatial,
  quantiles = c(0.1, 0.5, 0.9),
  line.color = viridis::viridis(
    3, #same number of colors as quantiles
    option = &amp;quot;F&amp;quot;, 
    end = 0.9
    ),
  ncol = 3,
  show.data = TRUE
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-27-1.png&#34; width=&#34;864&#34; /&gt;
&lt;p&gt;Setting the argument &lt;code&gt;quantiles&lt;/code&gt; to 0.5 and setting &lt;code&gt;show.data&lt;/code&gt; to &lt;code&gt;FALSE&lt;/code&gt; (default optioin) accentuates the shape of the response curves.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::plot_response_curves(
  model.non.spatial,
  quantiles = 0.5,
  ncol = 3
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-28-1.png&#34; width=&#34;864&#34; /&gt;
&lt;p&gt;The package 
&lt;a href=&#34;https://bgreenwell.github.io/pdp/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;pdp&lt;/code&gt;&lt;/a&gt; provides a general way to plot partial dependence plots.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pdp::partial(
  model.non.spatial, 
  train = plant_richness_df, 
  pred.var = &amp;quot;climate_bio1_average&amp;quot;, 
  plot = TRUE, 
  grid.resolution = 200
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-29-1.png&#34; width=&#34;384&#34; /&gt;
&lt;p&gt;If you need to do your own plots in a different way, the function 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/get_response_curves.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;get_response_curves()&lt;/code&gt;&lt;/a&gt; returns a data frame with the required data.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;reponse.curves.df &amp;lt;- spatialRF::get_response_curves(model.non.spatial)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;kableExtra::kbl(
  head(reponse.curves.df, n = 10),
  format = &amp;quot;html&amp;quot;
) %&amp;gt;%
  kableExtra::kable_paper(&amp;quot;hover&amp;quot;, full_width = F)
&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34; lightable-paper lightable-hover&#34; style=&#39;font-family: &#34;Arial Narrow&#34;, arial, helvetica, sans-serif; width: auto !important; margin-left: auto; margin-right: auto;&#39;&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; response &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; predictor &lt;/th&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; quantile &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; model &lt;/th&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; predictor.name &lt;/th&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; response.name &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3081.941 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -4.428994 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; 0.1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; richness_species_vascular &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3081.941 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -4.393562 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; 0.1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; richness_species_vascular &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3081.941 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -4.358129 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; 0.1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; richness_species_vascular &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3081.941 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -4.322697 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; 0.1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; richness_species_vascular &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3081.941 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -4.287265 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; 0.1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; richness_species_vascular &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3081.941 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -4.251833 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; 0.1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; richness_species_vascular &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3081.941 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -4.216400 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; 0.1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; richness_species_vascular &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3081.941 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -4.180968 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; 0.1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; richness_species_vascular &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3081.941 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -4.145536 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; 0.1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; richness_species_vascular &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 3081.941 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -4.110104 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; 0.1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1 &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; richness_species_vascular &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Interactions between two variables can be plotted with 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plot_response_surface.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;plot_response_surface()&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::plot_response_surface(
  model.non.spatial,
  a = &amp;quot;climate_bio1_average&amp;quot;,
  b = &amp;quot;neighbors_count&amp;quot;
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-32-1.png&#34; width=&#34;432&#34; /&gt;
&lt;p&gt;This can be done as well with the &lt;code&gt;pdp&lt;/code&gt; package, that uses a slightly different algorithm to plot interaction surfaces.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pdp::partial(
  model.non.spatial, 
  train = plant_richness_df, 
  pred.var = c(&amp;quot;climate_bio1_average&amp;quot;, &amp;quot;neighbors_count&amp;quot;), 
  plot = TRUE
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-33-1.png&#34; width=&#34;432&#34; /&gt;
&lt;h2 id=&#34;model-performance&#34;&gt;Model performance&lt;/h2&gt;
&lt;p&gt;The &lt;strong&gt;performance&lt;/strong&gt; slot (in &lt;code&gt;model.non.spatial$performance&lt;/code&gt;) contains the values of several performance measures. It be printed via the function 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/print_performance.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;print_performance()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::print_performance(model.non.spatial)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Model performance 
##   - R squared (oob):                  0.6075314
##   - R squared (cor(obs, pred)^2):     0.9543769
##   - Pseudo R squared (cor(obs, pred)):0.9769221
##   - RMSE (oob):                       2111.241
##   - RMSE:                             902.1424
##   - Normalized RMSE:                  0.2604337
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R squared (oob)&lt;/code&gt; and &lt;code&gt;RMSE (oob)&lt;/code&gt; are the R squared of the model and its root mean squared error when predicting the out-of-bag data (fraction of data not used to train individual trees). From all the values available in the &lt;code&gt;performance&lt;/code&gt; slot, probably these the most honest ones, as it is the closer trying to get a performance estimate on independent data. However, out-of-bag data is not fully independent, and therefore will still be inflated, especially if the data is highly aggregated in space.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R squared&lt;/code&gt; and &lt;code&gt;pseudo R squared&lt;/code&gt; are computed from the observations and the predictions, and indicate to what extent model outcomes represent the input data. These values will usually be high the data is highly aggregated in space.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;RMSE&lt;/code&gt; and its normalized version are computed via 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/root_mean_squared_error.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;root_mean_squared_error()&lt;/code&gt;&lt;/a&gt;, and are linear with &lt;code&gt;R squared&lt;/code&gt; and &lt;code&gt;pseudo R squared&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;spatial-cross-validation&#34;&gt;Spatial cross-validation&lt;/h2&gt;
&lt;p&gt;The function 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rf_evaluate.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rf_evaluate()&lt;/a&gt; overcomes the limitations of the performance scores explained above by providing honest performance based on &lt;em&gt;spatial cross-validation&lt;/em&gt;. The function separates the data into a number of spatially independent training and testing folds. Then, it fits a model on each training fold, predicts over each testing fold, and computes statistics of performance measures across folds. Let&amp;rsquo;s see how it works.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;model.non.spatial &amp;lt;- spatialRF::rf_evaluate(
  model = model.non.spatial,
  xy = xy,                  #data coordinates
  repetitions = 30,         #number of spatial folds
  training.fraction = 0.75, #training data fraction on each fold
  metrics = &amp;quot;r.squared&amp;quot;,
  seed = random.seed,
  verbose = FALSE
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function generates a new slot in the model named &lt;strong&gt;evaluation&lt;/strong&gt; (&lt;code&gt;model.non.spatial$evaluation&lt;/code&gt;) with several objects that summarize the spatial cross-validation results.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;names(model.non.spatial$evaluation)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;metrics&amp;quot;           &amp;quot;training.fraction&amp;quot; &amp;quot;spatial.folds&amp;quot;    
## [4] &amp;quot;per.fold&amp;quot;          &amp;quot;per.fold.long&amp;quot;     &amp;quot;per.model&amp;quot;        
## [7] &amp;quot;aggregated&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The slot &amp;ldquo;spatial.folds&amp;rdquo;, produced by 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/make_spatial_folds.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;make_spatial_folds()&lt;/code&gt;&lt;/a&gt;, contains the indices of the training and testing cases for each cross-validation repetition. The maps below show two sets of training and testing folds.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;pr &amp;lt;- plant_richness_df[, c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;)]
pr$group.2 &amp;lt;- pr$group.1 &amp;lt;- &amp;quot;Training&amp;quot;
pr[model.non.spatial$evaluation$spatial.folds[[1]]$testing, &amp;quot;group.1&amp;quot;] &amp;lt;- &amp;quot;Testing&amp;quot;
pr[model.non.spatial$evaluation$spatial.folds[[25]]$testing, &amp;quot;group.2&amp;quot;] &amp;lt;- &amp;quot;Testing&amp;quot;

p1 &amp;lt;- ggplot2::ggplot() +
  ggplot2::geom_sf(data = world, fill = &amp;quot;white&amp;quot;) +
  ggplot2::geom_point(data = pr,
          ggplot2::aes(
            x = x,
            y = y,
            color = group.1
            ),
          size = 2
          ) +
  ggplot2::scale_color_viridis_d(
    direction = -1, 
    end = 0.5, 
    alpha = 0.8, 
    option = &amp;quot;F&amp;quot;
    ) +
  ggplot2::theme_bw() +
  ggplot2::labs(color = &amp;quot;Group&amp;quot;) +
  ggplot2::scale_x_continuous(limits = c(-170, -30)) +
  ggplot2::scale_y_continuous(limits = c(-58, 80))  +
  ggplot2::ggtitle(&amp;quot;Spatial fold 1&amp;quot;) + 
  ggplot2::theme(
    legend.position = &amp;quot;none&amp;quot;, 
    plot.title = ggplot2::element_text(hjust = 0.5)
  ) + 
  ggplot2::xlab(&amp;quot;Longitude&amp;quot;) + 
  ggplot2::ylab(&amp;quot;Latitude&amp;quot;)

p2 &amp;lt;- ggplot2::ggplot() +
  ggplot2::geom_sf(data = world, fill = &amp;quot;white&amp;quot;) +
  ggplot2::geom_point(data = pr,
          ggplot2::aes(
            x = x,
            y = y,
            color = group.2
            ),
          size = 2
          ) +
  ggplot2::scale_color_viridis_d(
    direction = -1, 
    end = 0.5, 
    alpha = 0.8, 
    option = &amp;quot;F&amp;quot;
    ) +
  ggplot2::theme_bw() +
  ggplot2::labs(color = &amp;quot;Group&amp;quot;) +
  ggplot2::scale_x_continuous(limits = c(-170, -30)) +
  ggplot2::scale_y_continuous(limits = c(-58, 80)) +
  ggplot2::theme(
    plot.title = ggplot2::element_text(hjust = 0.5)
  ) + 
  ggplot2::ggtitle(&amp;quot;Spatial fold 25&amp;quot;) + 
  ggplot2::xlab(&amp;quot;Longitude&amp;quot;) + 
  ggplot2::ylab(&amp;quot;&amp;quot;)

p1 | p2
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-37-1.png&#34; width=&#34;960&#34; /&gt;
&lt;p&gt;The information available in this new slot can be accessed with the functions 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/print_evaluation.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;print_evaluation()&lt;/code&gt;&lt;/a&gt;, 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plot_evaluation.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;plot_evaluation()&lt;/code&gt;&lt;/a&gt;, and 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/get_evaluation.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;get_evaluation()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::plot_evaluation(model.non.spatial)
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-38-1.png&#34; width=&#34;432&#34; /&gt;
&lt;p&gt;&lt;code&gt;Full&lt;/code&gt; represents the R squared of the model trained on the full dataset. &lt;code&gt;Training&lt;/code&gt; are the R-squared of the models fitted on the spatial folds (named &lt;code&gt;Training&lt;/code&gt; in the maps above), and &lt;code&gt;Testing&lt;/code&gt; are the R-squared of the same models on &amp;ldquo;unseen&amp;rdquo; data (data not used to train the model, named &lt;code&gt;Testing&lt;/code&gt; in the maps above). The median, median absolute deviation (MAD), minimum, and maximum R-squared values on the testing folds can be printed with &lt;code&gt;print_evaluation()&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::print_evaluation(model.non.spatial)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Spatial evaluation 
##   - Training fraction:             0.75
##   - Spatial folds:                 29
## 
##     Metric Median   MAD Minimum Maximum
##  r.squared  0.517 0.085   0.122   0.781
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;other-important-things-stored-in-the-model&#34;&gt;Other important things stored in the model&lt;/h2&gt;
&lt;p&gt;The model predictions are stored in the slot &lt;strong&gt;predictions&lt;/strong&gt;, the arguments used to fit the model in &lt;strong&gt;ranger.arguments&lt;/strong&gt;, and the model itself, used to predict new values (see code chunk below), is in the &lt;strong&gt;forest&lt;/strong&gt; slot.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;predicted &amp;lt;- stats::predict(
  object = model.non.spatial,
  data = plant_richness_df,
  type = &amp;quot;response&amp;quot;
  )$predictions
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;fitting-a-spatial-model-with-rf_spatial&#34;&gt;Fitting a spatial model with &lt;code&gt;rf_spatial()&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;The spatial autocorrelation of the residuals of a model like &lt;code&gt;model.non.spatial&lt;/code&gt;, measured with 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Moran%27s_I&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Moran&amp;rsquo;s I&lt;/a&gt;, can be plotted with 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/plot_moran.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;plot_moran()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::plot_moran(
  model.non.spatial, 
  verbose = FALSE
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-41-1.png&#34; width=&#34;384&#34; /&gt;
According to the plot, the spatial autocorrelation of the residuals of `model.non.spatial` is highly positive for a neighborhood of 0 and 1000 km, while it becomes non-significant (p-value \&gt; 0.05) at 2000, 4000, and 8000 km. To reduce the spatial autocorrelation of the residuals as much as possible, the non-spatial model can be transformed into a *spatial model* very easily with the function [`rf_spatial()`](https://blasbenito.github.io/spatialRF/reference/rf_spatial.html). This function is the true core of the package!
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;model.spatial &amp;lt;- spatialRF::rf_spatial(
  model = model.non.spatial,
  method = &amp;quot;mem.moran.sequential&amp;quot;, #default method
  verbose = FALSE,
  seed = random.seed
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The plot below shows the Moran&amp;rsquo;s I of the residuals of the spatial model, and indicates that the residuals are not autocorrelated at any distance.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::plot_moran(
  model.spatial, 
  verbose = FALSE
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-43-1.png&#34; width=&#34;384&#34; /&gt;
&lt;p&gt;If we compare the variable importance plots of both models, we can see that the spatial model has an additional set of dots under the name &amp;ldquo;spatial_predictors&amp;rdquo;, and that the maximum importance of a few of these &lt;em&gt;spatial predictors&lt;/em&gt; matches the importance of the most relevant non-spatial predictors.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;p1 &amp;lt;- spatialRF::plot_importance(
  model.non.spatial, 
  verbose = FALSE) + 
  ggplot2::ggtitle(&amp;quot;Non-spatial model&amp;quot;) 

p2 &amp;lt;- spatialRF::plot_importance(
  model.spatial,
  verbose = FALSE) + 
  ggplot2::ggtitle(&amp;quot;Spatial model&amp;quot;)

p1 | p2 
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-44-1.png&#34; width=&#34;960&#34; /&gt;
&lt;p&gt;If we look at the ten most important variables in &lt;code&gt;model.spatial&lt;/code&gt; we will see that a few of them are &lt;em&gt;spatial predictors&lt;/em&gt;. Spatial predictors are named &lt;code&gt;spatial_predictor_X_Y&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is the neighborhood distance at which the predictor has been generated, and &lt;code&gt;Y&lt;/code&gt; is the index of the predictor.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;kableExtra::kbl(
  head(model.spatial$importance$per.variable, n = 10),
  format = &amp;quot;html&amp;quot;
) %&amp;gt;%
  kableExtra::kable_paper(&amp;quot;hover&amp;quot;, full_width = F)
&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34; lightable-paper lightable-hover&#34; style=&#39;font-family: &#34;Arial Narrow&#34;, arial, helvetica, sans-serif; width: auto !important; margin-left: auto; margin-right: auto;&#39;&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; variable &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; importance &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..neighbors_count &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1094.792 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_hypervolume &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1067.111 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; spatial_predictor_0_2 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 1035.365 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; human_population &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 997.965 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 973.243 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_area_km2..pca..neighbors_percent_shared_edge &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 902.209 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; climate_bio1_average..pca..human_population_density &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 882.910 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; spatial_predictor_0_1 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 815.656 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_area_km2 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 750.278 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; bias_species_per_record &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 712.031 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;But what are spatial predictors? Spatial predictors, as shown below, are smooth surfaces representing neighborhood among records at different spatial scales. They are computed from the distance matrix in different ways. The ones below are the eigenvectors of the double-centered distance matrix of weights (a.k.a, Moran&amp;rsquo;s Eigenvector Maps). They represent the effect of spatial proximity among records, helping to represent biogeographic and spatial processes not considered by the non-spatial predictors.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatial.predictors &amp;lt;- spatialRF::get_spatial_predictors(model.spatial)
pr &amp;lt;- data.frame(spatial.predictors, plant_richness_df[, c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;)])

p1 &amp;lt;- ggplot2::ggplot() +
  ggplot2::geom_sf(data = world, fill = &amp;quot;white&amp;quot;) +
  ggplot2::geom_point(
    data = pr,
    ggplot2::aes(
      x = x,
      y = y,
      color = spatial_predictor_0_2
    ),
    size = 2.5
  ) +
  ggplot2::scale_color_viridis_c(option = &amp;quot;F&amp;quot;) +
  ggplot2::theme_bw() +
  ggplot2::labs(color = &amp;quot;Eigenvalue&amp;quot;) +
  ggplot2::scale_x_continuous(limits = c(-170, -30)) +
  ggplot2::scale_y_continuous(limits = c(-58, 80))  +
  ggplot2::ggtitle(&amp;quot;Variable: spatial_predictor_0_2&amp;quot;) + 
  ggplot2::theme(legend.position = &amp;quot;bottom&amp;quot;)+ 
  ggplot2::xlab(&amp;quot;Longitude&amp;quot;) + 
  ggplot2::ylab(&amp;quot;Latitude&amp;quot;)

p2 &amp;lt;- ggplot2::ggplot() +
  ggplot2::geom_sf(data = world, fill = &amp;quot;white&amp;quot;) +
  ggplot2::geom_point(
    data = pr,
    ggplot2::aes(
      x = x,
      y = y,
      color = spatial_predictor_0_5,
    ),
    size = 2.5
  ) +
  ggplot2::scale_color_viridis_c(option = &amp;quot;F&amp;quot;) +
  ggplot2::theme_bw() +
  ggplot2::labs(color = &amp;quot;Eigenvalue&amp;quot;) +
  ggplot2::scale_x_continuous(limits = c(-170, -30)) +
  ggplot2::scale_y_continuous(limits = c(-58, 80))  +
  ggplot2::ggtitle(&amp;quot;Variable: spatial_predictor_0_5&amp;quot;) + 
  ggplot2::theme(legend.position = &amp;quot;bottom&amp;quot;) + 
  ggplot2::xlab(&amp;quot;Longitude&amp;quot;) + 
  ggplot2::ylab(&amp;quot;&amp;quot;)

p1 | p2
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-46-1.png&#34; width=&#34;1152&#34; /&gt;
&lt;p&gt;The spatial predictors are included in the model one by one, in the order of their Moran&amp;rsquo;s I (spatial predictors with Moran&amp;rsquo;s I lower than 0 are removed). The selection procedure is performed by the function 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/select_spatial_predictors_sequential.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;select_spatial_predictors_sequential()&lt;/code&gt;&lt;/a&gt;, which finds the smaller subset of spatial predictors maximizing the model&amp;rsquo;s R squared, and minimizing the Moran&amp;rsquo;s I of the residuals. This is shown in the optimization plot below (dots linked by lines represent the selected spatial predictors).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;p &amp;lt;- spatialRF::plot_optimization(model.spatial)
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-47-1.png&#34; width=&#34;576&#34; /&gt;
&lt;h1 id=&#34;tuning-random-forest-hyperparameters&#34;&gt;Tuning Random Forest hyperparameters&lt;/h1&gt;
&lt;p&gt;The model fitted above was based on the default random forest hyperparameters of &lt;code&gt;ranger()&lt;/code&gt;, and those might not be the most adequate ones for a given dataset. The function 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rf_tuning.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;rf_tuning()&lt;/code&gt;&lt;/a&gt; helps the user to choose sensible values for three Random Forest hyperparameters that are critical to model performance:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;num.trees&lt;/code&gt;: number of regression trees in the forest.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mtry&lt;/code&gt;: number of variables to choose from on each tree split.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min.node.size&lt;/code&gt;: minimum number of cases on a terminal node.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These values can be modified in any model fitted with the package using the &lt;code&gt;ranger.arguments&lt;/code&gt; argument. The example below shows how to fit a spatial model with a given set of hyperparameters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;model.spatial &amp;lt;- spatialRF::rf_spatial(
  model = model.non.spatial,
  method = &amp;quot;mem.moran.sequential&amp;quot;, #default method
  ranger.arguments = list(
    mtry = 5,
    min.node.size = 20,
    num.trees = 1000
  ),
  verbose = FALSE,
  seed = random.seed
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The usual method for model tuning relies on a grid search exploring the results of all the combinations of hyperparameters selected by the user. In &lt;code&gt;spatialRF&lt;/code&gt;,
model tuning is done via spatial cross-validation, to ensure that the selected combination of hyperparameters maximizes the ability of the model to predict over data not used to train it. &lt;strong&gt;Warning&lt;/strong&gt;: model tuning consumes a lot of computational resources, using it on large datasets might freeze your computer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: model tunning is very RAM-hungry, but you can control RAM usage by defining a lower value for the argument &lt;code&gt;n.cores&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;model.spatial &amp;lt;- rf_tuning(
  model = model.spatial,
  xy = xy,
  repetitions = 30,
  num.trees = c(500, 1000),
  mtry = seq(
    2,
    length(model.spatial$ranger.arguments$predictor.variable.names), #number of predictors
    by = 9),
  min.node.size = c(5, 15),
  seed = random.seed,
  verbose = FALSE
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function returns a tuned model only if the tuning finds a solution better than the original model. Otherwise the original model is returned. The results of the tuning are stored in the model under the name &amp;ldquo;tuning&amp;rdquo;.&lt;/p&gt;
&lt;h1 id=&#34;repeating-a-model-execution&#34;&gt;Repeating a model execution&lt;/h1&gt;
&lt;p&gt;Random Forest is an stochastic algorithm that yields slightly different results on each run unless a random seed is set. This particularity has implications for the interpretation of variable importance scores and response curves. The function 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rf_repeat.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;rf_repeat()&lt;/code&gt;&lt;/a&gt; repeats a model execution and yields the distribution of importance scores of the predictors across executions. &lt;strong&gt;NOTE&lt;/strong&gt;: this function works better when used at the end of a workflow&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;model.spatial.repeat &amp;lt;- spatialRF::rf_repeat(
  model = model.spatial, 
  repetitions = 30,
  seed = random.seed,
  verbose = FALSE
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The importance scores of a model fitted with &lt;code&gt;rf_repeat()&lt;/code&gt; are plotted as a violin plot, with the distribution of the importance scores of each predictor across repetitions.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::plot_importance(
  model.spatial.repeat, 
  verbose = FALSE
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-51-1.png&#34; width=&#34;576&#34; /&gt;
&lt;p&gt;The response curves of models fitted with &lt;code&gt;rf_repeat()&lt;/code&gt; can be plotted with &lt;code&gt;plot_response_curves()&lt;/code&gt; as well. The median prediction is shown with a thicker line.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::plot_response_curves(
  model.spatial.repeat, 
  quantiles = 0.5,
  ncol = 3
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-52-1.png&#34; width=&#34;864&#34; /&gt;
&lt;p&gt;The function &lt;code&gt;print_performance()&lt;/code&gt; generates a summary of the performance scores across model repetitions. As every other function of the package involving repetitions, the provided stats are the median, and the median absolute deviation (mad).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;spatialRF::print_performance(model.spatial.repeat)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Model performance (median +/- mad) 
##   - R squared (oob):              0.593 +/- 0.0098
##   - R squared (cor(obs, pred)^2): 0.957 +/- 0.0016
##   - Pseudo R squared:             0.978 +/- 8e-04
##   - RMSE (oob):                   2151.154 +/- 25.7818
##   - RMSE:                         914.973 +/- 15.5809
##   - Normalized RMSE:              0.264 +/- 0.0045
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;taking-advantage-of-the---pipe&#34;&gt;Taking advantage of the &lt;code&gt; %&amp;gt;%&lt;/code&gt; pipe&lt;/h1&gt;
&lt;p&gt;The modeling functions of &lt;code&gt;spatialRF&lt;/code&gt; are designed to facilitate using the pipe to combine them. The code below fits a spatial model, tunes its hyperparameters, evaluates it using spatial cross-validation, and repeats the execution several times, just by passing the model from one function to another. Replace &lt;code&gt;eval = FALSE&lt;/code&gt; with &lt;code&gt;eval = TRUE&lt;/code&gt; if you want to execute the code chunk.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;model.full &amp;lt;- rf_spatial(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance_matrix,
  distance.thresholds = distance.thresholds,
  xy = xy
) %&amp;gt;%
  rf_tuning() %&amp;gt;%
  rf_evaluate() %&amp;gt;%
  rf_repeat()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code structure shown above can also be used to take advantage of a custom cluster, either defined in the local host, or a Beowulf cluster.&lt;/p&gt;
&lt;p&gt;When working with a single machine, a cluster can be defined and used as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#creating and registering the cluster
local.cluster &amp;lt;- parallel::makeCluster(
  parallel::detectCores() - 1,
  type = &amp;quot;PSOCK&amp;quot;
)
doParallel::registerDoParallel(cl = local.cluster)

#fitting, tuning, evaluating, and repeating a model
model.full &amp;lt;- rf_spatial(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance_matrix,
  distance.thresholds = distance.thresholds,
  xy = xy,
  cluster = local.cluster #is passed via pipe to the other functions
) %&amp;gt;%
  rf_tuning() %&amp;gt;%
  rf_evaluate() %&amp;gt;%
  rf_repeat()

#stopping the cluster
parallel::stopCluster(cl = local.cluster)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To facilitate working with Beowulf clusters (
&lt;a href=&#34;https://www.blasbenito.com/post/01_home_cluster/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;just several computers connected via SSH&lt;/a&gt;), the package provides the function &lt;code&gt;beowulf_cluster()&lt;/code&gt;, that generates the cluster definition from details such as the IPs of the machines, the number of cores to be used on each machine, the user name, and the connection port.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#creating and registering the cluster
beowulf.cluster &amp;lt;- beowulf_cluster(
  cluster.ips = c(
    &amp;quot;10.42.0.1&amp;quot;,
    &amp;quot;10.42.0.34&amp;quot;,
    &amp;quot;10.42.0.104&amp;quot;
  ),
  cluster.cores = c(7, 4, 4),
  cluster.user = &amp;quot;blas&amp;quot;,
  cluster.port = &amp;quot;11000&amp;quot;
)

#fitting, tuning, evaluating, and repeating a model
model.full &amp;lt;- rf_spatial(
  data = plant_richness_df,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance_matrix,
  distance.thresholds = distance.thresholds,
  xy = xy,
  cluster = beowulf.cluster 
) %&amp;gt;%
  rf_tuning() %&amp;gt;%
  rf_evaluate() %&amp;gt;%
  rf_repeat()

doParallel::registerDoParallel(cl = beowulf.cluster)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;comparing-several-models&#34;&gt;Comparing several models&lt;/h1&gt;
&lt;p&gt;The function 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rf_compare.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;rf_compare()&lt;/code&gt;&lt;/a&gt; takes named list with as many models as the user needs to compare, and applies &lt;code&gt;rf_evaluate()&lt;/code&gt; to each one of them to compare their predictive performances across spatial folds.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;comparison &amp;lt;- spatialRF::rf_compare(
  models = list(
    `Non-spatial` = model.non.spatial,
    `Spatial` = model.spatial
  ),
  xy = xy,
  repetitions = 30,
  training.fraction = 0.8,
  metrics = &amp;quot;r.squared&amp;quot;,
  seed = random.seed
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-57-1.png&#34; width=&#34;576&#34; /&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- comparison$comparison.df %&amp;gt;% 
    dplyr::group_by(model, metric) %&amp;gt;% 
    dplyr::summarise(value = round(median(value), 3)) %&amp;gt;% 
    dplyr::arrange(metric) %&amp;gt;% 
    as.data.frame()
colnames(x) &amp;lt;- c(&amp;quot;Model&amp;quot;, &amp;quot;Metric&amp;quot;, &amp;quot;Median&amp;quot;)
kableExtra::kbl(
  x,
  format = &amp;quot;html&amp;quot;
  ) %&amp;gt;%
  kableExtra::kable_paper(&amp;quot;hover&amp;quot;, full_width = F)
&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34; lightable-paper lightable-hover&#34; style=&#39;font-family: &#34;Arial Narrow&#34;, arial, helvetica, sans-serif; width: auto !important; margin-left: auto; margin-right: auto;&#39;&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; Model &lt;/th&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; Metric &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; Median &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Non-spatial &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; r.squared &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.494 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Spatial &lt;/td&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; r.squared &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.305 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;working-with-a-binomial-response&#34;&gt;Working with a binomial response&lt;/h1&gt;
&lt;p&gt;This package can also perform binomial regression on response variables with zeros and ones. Let&amp;rsquo;s work on a quick example by turning the response variable of the previous models into a binomial one.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plant_richness_df$response_binomial &amp;lt;- ifelse(
  plant_richness_df$richness_species_vascular &amp;gt; 5000,
  1,
  0
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The new response variable, &lt;code&gt;response_binomial&lt;/code&gt;, will have ones where &lt;code&gt;richness_species_vascular &amp;gt; 5000&lt;/code&gt;, and zeros otherwise. This would be equivalent to having the classes &amp;ldquo;high richness&amp;rdquo; (represented by the ones) and &amp;ldquo;low richness&amp;rdquo;, represented by the zeros. The binomial regression model would then have as objective to compute the probability of each ecoregion to belong to the &amp;ldquo;high richness&amp;rdquo; class.&lt;/p&gt;
&lt;p&gt;There is something important to notice before moving forward though. The number of zeros in the new response variable is larger than the number of ones.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;table(plant_richness_df$response_binomial)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##   0   1 
## 165  62
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that there is &lt;strong&gt;class imbalance&lt;/strong&gt;, and under this scenario, any random forest model is going to get better at predicting the most abundant class, while in our case the &amp;ldquo;target&amp;rdquo; is the less abundant one. But the function &lt;code&gt;rf()&lt;/code&gt; is ready to deal with this issue. Let&amp;rsquo;s fit a model to see what am I talking about.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;model.non.spatial &amp;lt;- spatialRF::rf(
  data = plant_richness_df,
  dependent.variable.name = &amp;quot;response_binomial&amp;quot;,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance.matrix,
  distance.thresholds = distance.thresholds,
  seed = random.seed,
  verbose = FALSE
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function detects that the response variable is binary (using the function 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/is_binary.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;is_binary()&lt;/code&gt;&lt;/a&gt;), and computes &lt;em&gt;case weights&lt;/em&gt; for the ones and the zeros. These case weights are stored in the &lt;code&gt;ranger.arguments&lt;/code&gt; slot of the model, and are used to give preference to the cases with larger weights during the selection of the out-of-bag data (check the &lt;code&gt;case.weights&lt;/code&gt; argument in &lt;code&gt;ranger::ranger()&lt;/code&gt;). As a result, each individual tree in the forest is trained with a similar proportion of zeros and ones, which helps mitigate the class imbalance issue. This method is named &lt;em&gt;weighted Random Forest&lt;/em&gt;, and is very well explained in this 
&lt;a href=&#34;https://statistics.berkeley.edu/sites/default/files/tech-reports/666.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;white paper&lt;/a&gt; that includes the father of Random Forest, Leo Breiman, as coauthor.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;unique(model.non.spatial$ranger.arguments$case.weights)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.006060606 0.016129032
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This model could be projected right away onto a raster stack with maps of the predictors, so, in fact, &lt;code&gt;spatialRF&lt;/code&gt; can be used to fit Species Distribution Models, when it actually wasn&amp;rsquo;t really designed with such a purpose in mind. And as an additional advantage, the model can be evaluated with &lt;code&gt;rf_evaluate()&lt;/code&gt;, which is way better than cross-validation via random data-splitting (
&lt;a href=&#34;https://methodsblog.com/2018/11/29/blockcv-english/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this blog post&lt;/a&gt; explains explains why).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;model.non.spatial &amp;lt;- spatialRF::rf_evaluate(
  model.non.spatial,
  xy = xy,
  metrics = &amp;quot;auc&amp;quot;,
  verbose = FALSE
)

spatialRF::print_evaluation(model.non.spatial)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Spatial evaluation 
##   - Training fraction:             0.75
##   - Spatial folds:                 29
## 
##  Metric Median   MAD Minimum Maximum
##     auc  0.932 0.024    0.83   0.977
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;strong&gt;take away message&lt;/strong&gt; here is that you can work with a binomial response with &lt;code&gt;spatialRF&lt;/code&gt;, just as you would do with a continuous response, as long as it is represented with zeros and ones. Just remember that the class imbalance problem is tackled via case weights, and that predictive performance is also measured using the Area Under the ROC Curve (AUC).&lt;/p&gt;
&lt;h1 id=&#34;generating-spatial-predictors-for-other-modelling-methods&#34;&gt;Generating spatial predictors for other modelling methods&lt;/h1&gt;
&lt;p&gt;You might not love Random Forest, but &lt;code&gt;spatialRF&lt;/code&gt; loves you, and as such, it gives you tools to generate spatial predictors for other models anyway.&lt;/p&gt;
&lt;p&gt;The first step requires generating Moran&amp;rsquo;s Eigenvector Maps (MEMs) from the distance matrix. Here there are two options, computing MEMs for a single neighborhood distance with 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/mem.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;mem()&lt;/code&gt;&lt;/a&gt;, and computing MEMs for several neighborhood distances at once with 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/mem_multithreshold.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;mem_multithreshold()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#single distance (0km by default)
mems &amp;lt;- spatialRF::mem(distance.matrix = distance_matrix)

#several distances
mems &amp;lt;- spatialRF::mem_multithreshold(
  distance.matrix = distance.matrix,
  distance.thresholds = distance.thresholds
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In either case the result is a data frame with Moran&amp;rsquo;s Eigenvector Maps (&amp;ldquo;just&amp;rdquo; the positive eigenvectors of the double-centered distance matrix).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;kableExtra::kbl(
  head(mems[, 1:4], n = 10),
  format = &amp;quot;html&amp;quot;
) %&amp;gt;%
  kableExtra::kable_paper(&amp;quot;hover&amp;quot;, full_width = F)
&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34; lightable-paper lightable-hover&#34; style=&#39;font-family: &#34;Arial Narrow&#34;, arial, helvetica, sans-serif; width: auto !important; margin-left: auto; margin-right: auto;&#39;&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; spatial_predictor_0_1 &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; spatial_predictor_0_2 &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; spatial_predictor_0_3 &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; spatial_predictor_0_4 &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0259217 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0052203 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0416969 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0363324 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0996679 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0539713 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.1324480 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.3826928 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0010477 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0143046 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0443602 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0031386 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0165695 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0047991 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0307457 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0005170 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0225761 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0019595 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0230368 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0524239 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0155252 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0023742 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0197953 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0338956 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0229197 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0039860 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0312561 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0416697 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.2436009 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.1155295 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0791452 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0189996 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0150725 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0158684 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.1010284 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0095590 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.1187381 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0471879 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; -0.0359881 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.0065211 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;But not all MEMs are made equal, and you will need to rank them by their Moran&amp;rsquo;s I. The function 
&lt;a href=&#34;https://blasbenito.github.io/spatialRF/reference/rank_spatial_predictors.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;rank_spatial_predictors()&lt;/code&gt;&lt;/a&gt; will help you do so.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;mem.rank &amp;lt;- spatialRF::rank_spatial_predictors(
  distance.matrix = distance_matrix,
  spatial.predictors.df = mems,
  ranking.method = &amp;quot;moran&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output of &lt;code&gt;rank_spatial_predictors()&lt;/code&gt; is a list with three slots: &amp;ldquo;method&amp;rdquo;, a character string with the name of the ranking method; &amp;ldquo;criteria&amp;rdquo;, an ordered data frame with the criteria used to rank the spatial predictors; and &amp;ldquo;ranking&amp;rdquo;, a character vector with the names of the spatial predictors in the order of their ranking (it is just the first column of the &amp;ldquo;criteria&amp;rdquo; data frame). We can use this &amp;ldquo;ranking&amp;rdquo; object to reorder or &lt;code&gt;mems&lt;/code&gt; data frame.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;mems &amp;lt;- mems[, mem.rank$ranking]

#also:
#mems &amp;lt;- mem.rank$spatial.predictors.df
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From here, spatial predictors can be included in any model one by one, in the order of the ranking, until the spatial autocorrelation of the residuals becomes neutral, if possible. A little example with a linear model follows.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#model definition
predictors &amp;lt;- c(
  &amp;quot;climate_aridity_index_average &amp;quot;,
  &amp;quot;climate_bio1_average&amp;quot;,
  &amp;quot;bias_species_per_record&amp;quot;,
  &amp;quot;human_population_density&amp;quot;,
  &amp;quot;topography_elevation_average&amp;quot;,
  &amp;quot;fragmentation_division&amp;quot;
)
model.formula &amp;lt;- as.formula(
  paste(
    dependent.variable.name,
    &amp;quot; ~ &amp;quot;,
    paste(
      predictors,
      collapse = &amp;quot; + &amp;quot;
    )
  )
)

#scaling the data
model.data &amp;lt;- scale(plant_richness_df) %&amp;gt;% 
  as.data.frame()

#fitting the model
m &amp;lt;- lm(model.formula, data = model.data)

#Moran&#39;s I test of the residuals
moran.test &amp;lt;- spatialRF::moran(
  x = residuals(m),
  distance.matrix = distance_matrix,
  verbose = FALSE
)
moran.test$plot
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-68-1.png&#34; width=&#34;480&#34; /&gt;
&lt;p&gt;According to the Moran&amp;rsquo;s I test, the model residuals show spatial autocorrelation. Let&amp;rsquo;s introduce MEMs one by one until the problem is solved.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;#add mems to the data and applies scale()
model.data &amp;lt;- data.frame(
  plant_richness_df,
  mems
) %&amp;gt;%
  scale() %&amp;gt;%
  as.data.frame()

#initialize predictors.i
predictors.i &amp;lt;- predictors

#iterating through MEMs
for(mem.i in colnames(mems)){
  
  #add mem name to model definintion
  predictors.i &amp;lt;- c(predictors.i, mem.i)
  
  #generate model formula with the new spatial predictor
  model.formula.i &amp;lt;- as.formula(
    paste(
      dependent.variable.name,
      &amp;quot; ~ &amp;quot;,
      paste(
        predictors.i,
        collapse = &amp;quot; + &amp;quot;
      )
    )
  )
  
  #fit model
  m.i &amp;lt;- lm(model.formula.i, data = model.data)
  
  #Moran&#39;s I test
  moran.test.i &amp;lt;- moran(
    x = residuals(m.i),
    distance.matrix = distance_matrix,
    verbose = FALSE
  )
  
  #stop if no autocorrelation
  if(moran.test.i$test$interpretation == &amp;quot;No spatial correlation&amp;quot;){
    break
  }
  
}#end of loop

#last moran test
moran.test.i$plot
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;https://blasbenito.com/project/post-title/index_files/figure-html/unnamed-chunk-69-1.png&#34; width=&#34;480&#34; /&gt;
&lt;p&gt;Now we can compare the model without spatial predictors &lt;code&gt;m&lt;/code&gt; and the model with spatial predictors &lt;code&gt;m.i&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;comparison.df &amp;lt;- data.frame(
  Model = c(&amp;quot;Non-spatial&amp;quot;, &amp;quot;Spatial&amp;quot;),
  Predictors = c(length(predictors), length(predictors.i)),
  R_squared = round(c(summary(m)$r.squared, summary(m.i)$r.squared), 2),
  AIC = round(c(AIC(m), AIC(m.i)), 0),
  BIC = round(c(BIC(m), BIC(m.i)), 0),
  `Moran I` = round(c(moran.test$test$moran.i, moran.test.i$test$moran.i), 2)
)

kableExtra::kbl(
  comparison.df,
  format = &amp;quot;html&amp;quot;
) %&amp;gt;%
  kableExtra::kable_paper(&amp;quot;hover&amp;quot;, full_width = F)
&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34; lightable-paper lightable-hover&#34; style=&#39;font-family: &#34;Arial Narrow&#34;, arial, helvetica, sans-serif; width: auto !important; margin-left: auto; margin-right: auto;&#39;&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style=&#34;text-align:left;&#34;&gt; Model &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; Predictors &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; R_squared &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; AIC &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; BIC &lt;/th&gt;
   &lt;th style=&#34;text-align:right;&#34;&gt; Moran.I &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Non-spatial &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 6 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.38 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 551 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 578 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.21 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style=&#34;text-align:left;&#34;&gt; Spatial &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 22 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.50 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 533 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 615 &lt;/td&gt;
   &lt;td style=&#34;text-align:right;&#34;&gt; 0.06 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;According to the model comparison, it can be concluded that the addition of spatial predictors, in spite of the increase in complexity, has improved the model. In any case, this is just a simple demonstration of how spatial predictors generated with functions of the &lt;code&gt;spatialRF&lt;/code&gt; package can still help you fit spatial models with other modeling methods.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>R package &#39;virtualPollen&#39;</title>
      <link>https://blasbenito.com/project/virtualpollen/</link>
      <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://blasbenito.com/project/virtualpollen/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;https://CRAN.R-project.org/package=virtualPollen&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version-ago/virtualPollen&#34; alt=&#34;CRAN\_Release\_Badge&#34;&gt;&lt;/a&gt;

&lt;a href=&#34;https://CRAN.R-project.org/package=virtualPollen&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://cranlogs.r-pkg.org/badges/virtualPollen&#34; alt=&#34;CRAN\_Download\_Badge&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The goal of virtualPollen is to provide the tools to simulate pollen
curves over millenial time-scales generated by virtual taxa with
different life traits (life-span, fecundity, growth-rate) and niche
features (niche position and breadth) as a response to virtual
environmental drivers with a given temporal autocorrelation. It furthers
allow to simulate specific data properties of fossil pollen datasets,
such as sediment accumulation rate, and depth intervals between
consecutive pollen samples. The simulation outcomes are useful to better
understand the role of plant traits, niche properties, and climatic
variability in defining the shape of pollen curves.&lt;/p&gt;
&lt;p&gt;The 
&lt;a href=&#34;https://github.com/BlasBenito/virtualPollen&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub page&lt;/a&gt; of the package offers a complete tutorial on how to use the package. The 
&lt;a href=&#34;https://onlinelibrary.wiley.com/doi/full/10.1111/ecog.04772&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;paper published in the Ecography journal&lt;/a&gt; describes the foundations of the model in brief.&lt;/p&gt;
&lt;p&gt;If you ever use the package, please, cite it as:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Benito, B.M., Gil‐Romera, G. and Birks, H.J.B. (2020), Ecological memory at millennial time‐scales: the importance of data constraints, species longevity and niche features. Ecography, 43: 1-10. 
&lt;a href=&#34;https://doi.org/10.1111/ecog.04772&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://doi.org/10.1111/ecog.04772&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>R package `distantia`</title>
      <link>https://blasbenito.com/project/distantia/</link>
      <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://blasbenito.com/project/distantia/</guid>
      <description>&lt;!-- badges: start --&gt;
&lt;p&gt;
&lt;a href=&#34;https://zenodo.org/badge/latestdoi/187805264&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://zenodo.org/badge/187805264.svg&#34; alt=&#34;DOI&#34;&gt;&lt;/a&gt;

&lt;a href=&#34;https://CRAN.R-project.org/package=distantia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version-ago/distantia&#34; alt=&#34;CRAN\_Release\_Badge&#34;&gt;&lt;/a&gt;

&lt;a href=&#34;https://CRAN.R-project.org/package=distantia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://cranlogs.r-pkg.org/badges/distantia&#34; alt=&#34;CRAN\_Download\_Badge&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;!-- badges: end --&gt;
&lt;p&gt;The package &lt;em&gt;distantia&lt;/em&gt; allows to measure the dissimilarity between multivariate time-series. The package assumes that the target sequences are ordered along a given dimension, being depth and time the most common ones, but others such as latitude or elevation are also possible. Furthermore, the target time-series can be regular or irregular, and have their samples aligned (same age/time/depth) or unaligned (different age/time/depth). The only requirement is that the sequences must have at least two (but ideally more) columns with the same name and units representing different variables relevant to the dynamics of a system of interest.&lt;/p&gt;
&lt;p&gt;The 
&lt;a href=&#34;https://github.com/BlasBenito/distantia&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub page&lt;/a&gt; of the project contains a thorough explanation of the statistics behind the method. The 
&lt;a href=&#34;https://onlinelibrary.wiley.com/doi/full/10.1111/ecog.04895&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;paper published in the Ecography journal&lt;/a&gt; describes the method, the package, and a couple of practical examples. The code and data used to develop the examples can be found in 
&lt;a href=&#34;https://github.com/BlasBenito/distantiaPaper&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; and 
&lt;a href=&#34;https://zenodo.org/record/3520959#.X94GNtYo-1c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Zenodo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Please, if you find this package useful, please cite it as:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Benito, B.M. and Birks, H.J.B. (2020), distantia: an open‐source toolset to quantify dissimilarity between multivariate ecological time‐series. Ecography, 43: 660-667. 
&lt;a href=&#34;https://doi.org/10.1111/ecog.04895&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://doi.org/10.1111/ecog.04895&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>R package `memoria`</title>
      <link>https://blasbenito.com/project/memoria/</link>
      <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://blasbenito.com/project/memoria/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;https://zenodo.org/badge/latestdoi/179102027&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://zenodo.org/badge/179102027.svg&#34; alt=&#34;DOI&#34;&gt;&lt;/a&gt;

&lt;a href=&#34;https://CRAN.R-project.org/package=memoria&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://www.r-pkg.org/badges/version-ago/memoria&#34; alt=&#34;CRAN\_Release\_Badge&#34;&gt;&lt;/a&gt;

&lt;a href=&#34;https://CRAN.R-project.org/package=memoria&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;https://cranlogs.r-pkg.org/badges/memoria&#34; alt=&#34;CRAN\_Download\_Badge&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The goal of &lt;em&gt;memoria&lt;/em&gt; is to provide the tools to quantify &lt;strong&gt;ecological
memory&lt;/strong&gt; in long time-series involving environmental drivers and biotic
responses, including palaeoecological datasets.&lt;/p&gt;
&lt;p&gt;Ecological memory has two main components: the &lt;em&gt;endogenous&lt;/em&gt; component,
which represents the effect of antecedent values of the response on
itself, and &lt;em&gt;endogenous&lt;/em&gt; component, which represents the effect of
antecedent values of the driver or drivers on the current state of the
biotic response. Additionally, the &lt;em&gt;concurrent effect&lt;/em&gt;, which represents
the synchronic effect of the environmental drivers over the response is
measured. The functions in the package allow the user&lt;/p&gt;
&lt;p&gt;The package &lt;em&gt;memoria&lt;/em&gt; uses the fast implementation of Random Forest
available in the 
&lt;a href=&#34;https://CRAN.R-project.org/package=ranger&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ranger&lt;/a&gt;
package to fit a model of the form shown in &lt;strong&gt;Equation 1&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Equation 1&lt;/strong&gt; (simplified from the one in the paper):
$$p_{t} = p_{t-1} +&amp;hellip;+ p_{t-n} + d_{t} + d_{t-1} +&amp;hellip;+ d_{t-n}$$&lt;/p&gt;
&lt;p&gt;Where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$p$ is the response variable, &lt;em&gt;Pollen&lt;/em&gt; counts were used in this particular case..&lt;/li&gt;
&lt;li&gt;$d$ is an environmental &lt;em&gt;Driver&lt;/em&gt; influencing the response variable.&lt;/li&gt;
&lt;li&gt;$t$ is the time of any given value of the response $p$.&lt;/li&gt;
&lt;li&gt;$t-1$ is the lag 1.&lt;/li&gt;
&lt;li&gt;$p_{t-1} +&amp;hellip;+ p_{t-n}$ represents the endogenous component of
ecological memory.&lt;/li&gt;
&lt;li&gt;$d_{t-1} +&amp;hellip;+ d_{t-n}$ represents the exogenous component of
ecological memory.&lt;/li&gt;
&lt;li&gt;$d_{t}$ represents the concurrent effect of the driver over the
response.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Random Forest returns an importance score for each model term, and the
functions in &lt;em&gt;memoria&lt;/em&gt; let the user to plot the importance scores across
time lags for each ecological memory components, and to compute
different features of each memory component (length, strength, and
dominance).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;output.png&#34; alt=&#34;Outputs produced by memoria from the analysis of a multivariate time series&#34;&gt;&lt;/p&gt;
&lt;p&gt;The 
&lt;a href=&#34;https://github.com/BlasBenito/memoria&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub page&lt;/a&gt; of the package features complete examples on how to use the package. The 
&lt;a href=&#34;https://onlinelibrary.wiley.com/doi/full/10.1111/ecog.04772&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;paper published in the Ecography journal&lt;/a&gt; describes ecological memory concepts and the method based on Random Forest used to assess ecological memory components. The code used to generate the supplementary materials can be found in 
&lt;a href=&#34;https://github.com/BlasBenito/EcologicalMemory&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; and 
&lt;a href=&#34;https://zenodo.org/record/3236128#.X941v9Yo-1c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Zenodo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you ever use the package, please, cite it as:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Benito, B.M., Gil‐Romera, G. and Birks, H.J.B. (2020), Ecological memory at millennial time‐scales: the importance of data constraints, species longevity and niche features. Ecography, 43: 1-10. 
&lt;a href=&#34;https://doi.org/10.1111/ecog.04772&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://doi.org/10.1111/ecog.04772&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>distantia: an open‐source toolset to quantify dissimilarity between multivariate ecological time‐series</title>
      <link>https://blasbenito.com/publication/2020_benito_ecography_distantia/</link>
      <pubDate>Thu, 23 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://blasbenito.com/publication/2020_benito_ecography_distantia/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Ecological memory at millennial time‐scales: the importance of data constraints, species longevity and niche features</title>
      <link>https://blasbenito.com/publication/2020_benito_ecography_memoria/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://blasbenito.com/publication/2020_benito_ecography_memoria/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
