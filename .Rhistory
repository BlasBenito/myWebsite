#non-collinear predictors
rf_ab <- ranger::ranger(
formula = y ~ a + b,
data = df,
importance = "permutation",
seed = 1 #for reproducibility
)
#collinear predictors
rf_abcd <- ranger::ranger(
formula = y ~ a + b + c + d,
data = df,
importance = "permutation",
seed = 1
)
rf_ab$prediction.error
rf_abcd$prediction.error
rf_ab$variable.importance |> round(4)
rf_abcd$variable.importance |> round(4)
rf_abc <- ranger::ranger(
formula = y ~ a + b + c,
data = df,
importance = "permutation",
seed = 1
)
rf_abc$variable.importance |> round(4)
preference <- collinear::preference_order(
df = df,
response = "y",
predictors = c("a", "b", "c", "d")
)
preference
variable_selection <- collinear::collinear(
df = df,
response = "y",
predictors = c("a", "b", "c", "d"),
preference_order = preference,
max_cor = 0.5,
max_vif = 2.5
)
variable_selection
vif_df(
df = df,
response = "y",
predictors = c("a", "b", "c", "d")
)
cor_df(
df = df,
response = "y",
predictors = c("a", "b", "c", "d")
)
vif_df(
df = df,
response = "y",
predictors = c("a", "b", "c", "d")
)
cor_df(
df = df,
predictors = c("a", "b", "c", "d")
)
cor_df(
df = df,
response = "y"
)
cor_df(
df = df,
predictors = c("a", "b", "c", "d")
)
#more concise, if there are only responses and predictors in df
cor_df(
df = df,
response = "y"
)
cor_df(
df = df,
predictors = c("a", "b", "c", "d"),
method = "spearman"
)
cor_df(
df = df,
predictors = c("a", "b", "c", "d"),
cor_method = "spearman"
)
#more concise, if df only has response and predictors
# cor_df(
#   df = df,
#   response = "y"
# )
collinear::cor_df(
df = df,
predictors = c("a", "b", "c", "d"),
method = "pearson" #default
)
collinear::cor_df(
df = df,
predictors = c("a", "b", "c", "d"),
cor_method = "pearson" #default
)
#load the collinear package and its example data
library(collinear)
data(vi)
#other required libraries
library(ranger)
library(dplyr)
set.seed(1)
df <- vi |>
dplyr::slice_sample(n = 2000) |>
dplyr::transmute(
a = soil_clay,
b = humidity_range
) |>
scale() |>
as.data.frame() |>
dplyr::mutate(
y = a * 0.75 + b * 0.25 + runif(n = dplyr::n(), min = -0.5, max = 0.5),
c = a + runif(n = dplyr::n(), min = -0.5, max = 0.5),
d = (a + b)/2 + runif(n = dplyr::n(), min = -0.5, max = 0.5)
)
collinear::cor_df(
df = df,
predictors = c("a", "b", "c", "d")
)
#non-collinear predictors
lm_ab <- lm(
formula = y ~ a + b,
data = df
)
#collinear predictors
lm_abcd <- lm(
formula = y ~ a + b + c + d,
data = df
)
coefficients(lm_ab)[2:3] |>
round(4)
coefficients(lm_abcd)[2:5] |>
round(4)
#predictors names
predictors <- c("a", "b", "c", "d")
#QR decomposition of predictors
df.qr <- qr(df[, predictors])
#extract Q matrix
df.q <- qr.Q(df.qr)
colnames(df.q) <- predictors
#correlation between transformed predictors
collinear::cor_df(df = df.q)
solve(a = df.qr, b = df$y) |>
round(4)
summary(lm_ab)$coefficients[, "Std. Error"][2:3] |>
round(4)
summary(lm_abcd)$coefficients[, "Std. Error"][2:5] |>
round(4)
#non-collinear predictors
rf_ab <- ranger::ranger(
formula = y ~ a + b,
data = df,
importance = "permutation",
seed = 1 #for reproducibility
)
#collinear predictors
rf_abcd <- ranger::ranger(
formula = y ~ a + b + c + d,
data = df,
importance = "permutation",
seed = 1
)
rf_ab$prediction.error
rf_abcd$prediction.error
rf_ab$variable.importance |> round(4)
rf_abcd$variable.importance |> round(4)
rf_abc <- ranger::ranger(
formula = y ~ a + b + c,
data = df,
importance = "permutation",
seed = 1
)
rf_abc$variable.importance |> round(4)
collinear::cor_df(
df = df,
predictors = c("a", "b", "c", "d"),
cor_method = "pearson" #default
)
#more concise, if df only has response and predictors
# collinear::cor_df(
#   df = df,
#   response = "y"
# )
#load the collinear package and its example data
library(collinear)
data(vi)
#other required libraries
library(ranger)
library(dplyr)
set.seed(1)
df <- vi |>
dplyr::slice_sample(n = 2000) |>
dplyr::transmute(
a = soil_clay,
b = humidity_range
) |>
scale() |>
as.data.frame() |>
dplyr::mutate(
y = a * 0.75 + b * 0.25 + runif(n = dplyr::n(), min = -0.5, max = 0.5),
c = a + runif(n = dplyr::n(), min = -0.5, max = 0.5),
d = (a + b)/2 + runif(n = dplyr::n(), min = -0.5, max = 0.5)
)
collinear::cor_df(
df = df,
predictors = c("a", "b", "c", "d")
)
#non-collinear predictors
lm_ab <- lm(
formula = y ~ a + b,
data = df
)
#collinear predictors
lm_abcd <- lm(
formula = y ~ a + b + c + d,
data = df
)
coefficients(lm_ab)[2:3] |>
round(4)
coefficients(lm_abcd)[2:5] |>
round(4)
#predictors names
predictors <- c("a", "b", "c", "d")
#QR decomposition of predictors
df.qr <- qr(df[, predictors])
#extract Q matrix
df.q <- qr.Q(df.qr)
colnames(df.q) <- predictors
#correlation between transformed predictors
collinear::cor_df(df = df.q)
solve(a = df.qr, b = df$y) |>
round(4)
summary(lm_ab)$coefficients[, "Std. Error"][2:3] |>
round(4)
summary(lm_abcd)$coefficients[, "Std. Error"][2:5] |>
round(4)
#non-collinear predictors
rf_ab <- ranger::ranger(
formula = y ~ a + b,
data = df,
importance = "permutation",
seed = 1 #for reproducibility
)
#collinear predictors
rf_abcd <- ranger::ranger(
formula = y ~ a + b + c + d,
data = df,
importance = "permutation",
seed = 1
)
rf_ab$prediction.error
rf_abcd$prediction.error
rf_ab$variable.importance |> round(4)
rf_abcd$variable.importance |> round(4)
rf_abc <- ranger::ranger(
formula = y ~ a + b + c,
data = df,
importance = "permutation",
seed = 1
)
rf_abc$variable.importance |> round(4)
collinear::cor_df(
df = df,
predictors = c("a", "b", "c", "d"),
cor_method = "pearson" #default
)
#more concise, if df only has response and predictors
# collinear::cor_df(
#   df = df,
#   response = "y"
# )
lm_a <- lm(
formula = a ~ b + c + d,
data = df
)
vif_a <- summary(lm_a)$r_squared
vif_a
summary(lm_a)
lm_a <- lm(
formula = a ~ b + c + d,
data = df
) |>
summary()
lm_a <- lm(
formula = a ~ b + c + d,
data = df
) |>
summary()
rsquared_a <- lm_a$r.squared
vif_a <- 1(1-rsquared_a)
#summary of multiple regression model
lm_a <- lm(
formula = a ~ b + c + d,
data = df
) |>
summary()
#r-squared
rsquared_a <- lm_a$r.squared
#vif
vif_a <- 1/(1-rsquared_a)
vif_a
vif_df(
df = df,
response = "y",
predictors = c("a", "b", "c", "d")
)
lm_a <- lm(
formula = a ~ b + c + d,
data = df
)
cor(predict(lm_a), df$a)
lm_a <- lm(
formula = a ~ b + c + d,
data = df
) |>
summary()
#r-squared
rsquared_a <- lm_a$r.squared
rsquared_a
lm_a <- lm(
formula = a ~ b + c + d,
data = df
)
cor(predict(lm_a), df$a)
sqrt(cor(predict(lm_a), df$a))
cor(predict(lm_a), df$a)^2
#summary of multiple regression model
lm_a <- lm(
formula = a ~ b + c + d,
data = df
) |>
summary()
#r-squared
rsquared_a <- lm_a$r.squared
#alternative way to compute R-squared
#cor(predict(lm_a), df$a)^2
#vif
vif_a <- 1/(1-rsquared_a)
vif_a
collinear::vif_df(
df = df,
predictors = c("a", "b", "c", "d")
)
#more concise, if there are only responses and predictors in df
# collinear::vif_df(
#   df = df,
#   response = "y"
# )
collinear::vif_df(
df = df,
predictors = c("b", "c", "d")
)
collinear::vif_df(
df = df,
predictors = c("b", "c")
)
df_correlation |>
dplyr::filter(
y != "a" | y != "a"
)
df_correlation <- collinear::cor_df(
df = df,
predictors = c("a", "b", "c", "d"),
cor_method = "pearson" #default
)
#more concise, if df only has response and predictors
# df_correlation <- collinear::cor_df(
#   df = df,
#   response = "y"
# )
df_correlation
df_correlation |>
dplyr::filter(
y != "a" | y != "a"
)
collinear::vif_df(
df = df,
predictors = c("a", "b", "c", "d")
)
#more concise, if there are only responses and predictors in df
# collinear::vif_df(
#   df = df,
#   response = "y"
# )
df_vif <- collinear::vif_df(
df = df,
predictors = c("a", "b", "c", "d")
)
#more concise, if there are only responses and predictors in df
# sf_vif <- collinear::vif_df(
#   df = df,
#   response = "y"
# )
df_vif
df_correlation <- collinear::cor_df(
df = df,
predictors = c("a", "b", "c", "d"),
cor_method = "pearson" #default
)
#more concise, if df only has response and predictors
# df_correlation <- collinear::cor_df(
#   df = df,
#   response = "y"
# )
df_correlation
df_vif <- collinear::vif_df(
df = df,
predictors = c("a", "b", "c", "d")
)
#more concise, if there are only responses and predictors in df
# sf_vif <- collinear::vif_df(
#   df = df,
#   response = "y"
# )
df_vif
#load the collinear package and its example data
library(collinear)
data(vi)
#other required libraries
library(ranger)
library(dplyr)
#predictors names
predictors <- c("a", "b", "c", "d")
#QR decomposition of predictors
df.qr <- qr(df[, predictors])
#load the collinear package and its example data
library(collinear)
data(vi)
#other required libraries
library(ranger)
library(dplyr)
set.seed(1)
df <- vi |>
dplyr::slice_sample(n = 2000) |>
dplyr::transmute(
a = soil_clay,
b = humidity_range
) |>
scale() |>
as.data.frame() |>
dplyr::mutate(
y = a * 0.75 + b * 0.25 + runif(n = dplyr::n(), min = -0.5, max = 0.5),
c = a + runif(n = dplyr::n(), min = -0.5, max = 0.5),
d = (a + b)/2 + runif(n = dplyr::n(), min = -0.5, max = 0.5)
)
collinear::cor_df(
df = df,
predictors = c("a", "b", "c", "d")
)
#non-collinear predictors
lm_ab <- lm(
formula = y ~ a + b,
data = df
)
#collinear predictors
lm_abcd <- lm(
formula = y ~ a + b + c + d,
data = df
)
coefficients(lm_ab)[2:3] |>
round(4)
coefficients(lm_abcd)[2:5] |>
round(4)
#predictors names
predictors <- c("a", "b", "c", "d")
#QR decomposition of predictors
df.qr <- qr(df[, predictors])
#extract Q matrix
df.q <- qr.Q(df.qr)
colnames(df.q) <- predictors
#correlation between transformed predictors
collinear::cor_df(df = df.q)
solve(a = df.qr, b = df$y) |>
round(4)
summary(lm_ab)$coefficients[, "Std. Error"][2:3] |>
round(4)
summary(lm_abcd)$coefficients[, "Std. Error"][2:5] |>
round(4)
summary(lm_ab)$coefficients[, "Std. Error"][2:3] |>
round(4)
summary(lm_abcd)$coefficients[, "Std. Error"][2:5] |>
round(4)
#non-collinear predictors
rf_ab <- ranger::ranger(
formula = y ~ a + b,
data = df,
importance = "permutation",
seed = 1 #for reproducibility
)
#collinear predictors
rf_abcd <- ranger::ranger(
formula = y ~ a + b + c + d,
data = df,
importance = "permutation",
seed = 1
)
rf_ab$prediction.error
rf_abcd$prediction.error
rf_ab$variable.importance |> round(4)
rf_abcd$variable.importance |> round(4)
blogdown::serve_site()
blogdown::serve_site()
blogdown::stop_server()
blogdown::serve_site()
blogdown::stop_server()
blogdown::serve_site()
blogdown::stop_server()
blogdown::serve_site()
blogdown::stop_server()
blogdown::serve_site()
