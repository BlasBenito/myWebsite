center = TRUE,
scale = TRUE
)
zoo_spain_scaled
class(zoo_spain_scaled)
#' Linear Detrending and Normalization
#' @param x (required, zoo object) time series to detrend.
#' @return zoo object
ts_preprocessing <- function(x){
m <- stats::lm(formula = x ~ stats::time(x))
y <- stats::residuals(object = m)
y.scaled <- scale(x = y)
y.scaled
}
source("mini_dtw.R")
zoo_spain_ready <- ts_preprocessing(x = zoo_spain)
plot(
x = zoo_spain_ready,
col = "red4",
mar = c(0.5, 5, 0, 5)
)
#' Euclidean Distance
#' @param x (required, numeric) row of a zoo object.
#' @param y (required, numeric) row of a zoo object.
#' @return numeric
d_euclidean <- function(x, y){
d <- sqrt(sum((x-y)^2))
d
}
d_euclidean(
x = zoo::coredata(zoo_germany)[1, ],
y = zoo::coredata(zoo_spain)[2, ]
)
d_euclidean(
x = zoo_germany[1, ],
y = zoo_spain[2, ]
)
d_euclidean(
x = as.numeric(zoo_germany[1, ]),
y = as.numeric(zoo_spain[2, ])
)
#' Euclidean Distance
#' @param x (required, numeric) row of a zoo object.
#' @param y (required, numeric) row of a zoo object.
#' @return numeric
d_euclidean <- function(x, y){
x <- as.numeric(x)
y <- as.numeric(y)
d <- sqrt(sum((x-y)^2))
d
}
d_euclidean(
x = zoo_germany[1, ],
y = zoo_spain[2, ]
)
m_dist <- matrix(
data = NA,
nrow = nrow(zoo_spain),
ncol = nrow(zoo_germany)
)
for(row.i in 1:nrow(zoo_spain)){
for(col.j in 1:nrow(zoo_germany)){
m_dist[row.i, col.j] <- d_euclidean(
x = zoo_spain[row.i, ],
y = zoo_germany[col.j, ]
)
}
}
m_dist[1:5, 1:5]
par(mar = c(4, 4, 1, 1))
graphics::image(
x = m_dist,
xlab = "zoo_spain",
ylab = "zoo_germany"
)
#' Distance Matrix Between Time Series
#' @param x (required, zoo object) time series.
#' @param y (required, zoo object) time series with same columns as `x`
#' @return matrix
distance_matrix <- function(x, y){
m_dist <- matrix(
data = NA,
nrow = nrow(y),
ncol = nrow(x)
)
for(row.i in 1:nrow(y)){
for(col.j in 1:nrow(x)){
m_dist[row.i, col.j] <- d_euclidean(
x = x[row.i, ],
y = y[col.j, ]
)
}
}
m_dist
}
m_dist <- distance_matrix(
x = zoo_spain,
y = zoo_sweden
)
par(mar = c(4, 4, 1, 1))
graphics::image(
x = m_dist,
xlab = "zoo_sweden",
ylab = "zoo_spain"
)
m_cost <- matrix(
data = NA,
nrow = nrow(m_dist),
ncol = ncol(m_dist)
)
m_cost[1, ] <- cumsum(m_dist[1, ])
m_cost[, 1] <- cumsum(m_dist[, 1])
par(mar = c(4, 4, 1, 1))
graphics::image(
x = m_cost,
xlab = "zoo_sweden",
ylab = "zoo_spain"
)
m_cost[1:2, 1:2]
m_cost[2, 2] <- min(
m_cost[1, 2],
m_cost[2, 1]
) + m_dist[2, 2]
m_cost[1:2, 1:2]
par(mar = c(4, 4, 1, 1))
graphics::image(
x = m_cost,
xlab = "zoo_sweden",
ylab = "zoo_spain"
)
#iterate over rows of the cost matrix
for(row.i in 2:nrow(m_dist)){
#iterate over columns of the cost matrix
for(col.j in 2:ncol(m_dist)){
#get cost of neighbor with minimum accumulated cost
min_cost <- min(
m_cost[row.i - 1, col.j],
m_cost[row.i, col.j - 1]
)
#add it to the distance of the target cell
new_value <- min_cost + m_dist[row.i, col.j]
#fill the empty cell with the new value
m_cost[row.i, col.j] <- new_value
}
}
m <- nrow(m_cost)
n <- ncol(m_cost)
m_cost[(m-1):m, (n-1):n]
m_cost[m, n] <- m_cost[m, n] + m_cost[1, 1]
m_cost[(m-1):m, (n-1):n]
#' Cost Matrix from Distance Matrix
#' @param m (required, matrix) distance matrix.
#' @return matrix
cost_matrix <- function(m){
m_cost <- matrix(
data = NA,
nrow = nrow(m),
ncol = ncol(m)
)
m_cost[1, ] <- cumsum(m[1, ])
m_cost[, 1] <- cumsum(m[, 1])
for(row.i in 2:nrow(m)){
for(col.j in 2:ncol(m)){
m_cost[row.i, col.j] <- min(
m_cost[row.i - 1, col.j],
m_cost[row.i, col.j - 1]
) + m[row.i, col.j]
}
}
m_cost[row.i, col.j] <- m_cost[row.i, col.j] + m_cost[1, 1]
m_cost
}
m_cost <- cost_matrix(m = m_dist)
par(mar = c(4, 4, 1, 1))
graphics::image(
x = m_cost,
xlab = "zoo_sweden",
ylab = "zoo_spain"
)
m_cost[(m-1):m, (n-1):n]
poi_row <- 4
poi_col <- 3
x <- 5
y <- 5
m <- m_cost
poi_x <- c(x - 1, x)
poy_y <- c(y, y - 1)
poi_x
poy_y
up <- c(x - 1, y)
left <- c(y, y - 1)
up
up <- c(x, y - 1)
up
x <- 5
y <- 5
m <- m_cost
up <- c(x, y - 1)
left <- c(x - 1, y)
up
left
x <- 5
y <- 5
m <- m_cost
y_move <- max(y - 1, 1)
x_move <- max(x - 1, 1)
up <- c(x, y_move)
left <- c(x_move, y)
up
left
y_move <- max(y - 1, 1)
x_move <- max(x - 1, 1)
y_neigh <- c(x, y_move)
x_neigh <- c(x_move, y)
y_neigh
x_neigh
y_neigh <- c(x, y_move)
x_neigh <- c(x_move, y)
y_neigh
x_neigh
y_move <- max(y - 1, 1)
x_move <- max(x - 1, 1)
neighbors <- list(
y = c(x, y_move),
x = c(x_move, y)
)
neighbors
neighbors <- list(
y = c(x, y_move),
x = c(x_move, y)
)
lapply(
X = neighbors,
FUN = function(x) m[x]
)
x
x <- neighbors[[1]]
m[x]
m[x]
m[c(x, y_move)]
c(x, y_move)
x <- 5
y <- 5
m <- m_cost
y_move <- max(y - 1, 1)
x_move <- max(x - 1, 1)
neighbors <- list(
y = c(x, y_move),
x = c(x_move, y)
)
neighbors
m[c(x, y_move)]
m[1, 1]
y_move <- max(y - 1, 1)
x_move <- max(x - 1, 1)
neighbors <- data.frame(
x = c(x, x_move),
y = c(y_move, y),
move = c("up", "left")
)
neighbors
neighbors
y_move <- max(y - 1, 1)
x_move <- max(x - 1, 1)
neighbors <- data.frame(
x = c(x, x_move),
y = c(y_move, y),
move = c("up", "left")
)
neighbors <- data.frame(
x = c(x, x_move),
y = c(y_move, y),
move = c("up", "left"),
cost = NA
)
neighbors
neighbors
sapply
help(sapply)
neighbors <- data.frame(
x = c(x, x_move),
y = c(y_move, y),
move = c("up", "left"),
cost = NA
)
as.list(neighbors)
#neighbors data frame
neighbors <- data.frame(
x = c(x, x_move),
y = c(y_move, y),
move = c("up", "left")
)
neighbors
neighbors <- data.frame(
x = c(x, x_move),
y = c(y_move, y),
move = c("up", "left"),
cost = NA
)
help(apply)
apply(
X = neighbors,
MARGIN = 1,
FUN = m[x$x, x$y]
)
apply(
X = neighbors,
MARGIN = 1,
FUN = function(x) print(x)
)
neighbors <- data.frame(
x = c(x, x_move),
y = c(y_move, y)
)
neighbors
neighbors
help(data.frame)
neighbors <- data.frame(
x = c(x, x_move),
y = c(y_move, y),
row.names = c("up", "left")
)
neighbors
m[neighbors$x, neighbors$y]
neighbors$x
apply(
X = neighbors,
MARGIN = 1,
FUN = function(x) print(x)
)
apply(
X = neighbors,
MARGIN = 1,
FUN = function(x) m[x$x, x$y]
)
apply(
X = neighbors,
MARGIN = 1,
FUN = function(x) m[x[1], x[2]]
)
apply(
X = neighbors,
MARGIN = 1,
FUN = function(x) m[x[1], x[2]]
) |>
min() |>
names()
apply(
X = neighbors,
MARGIN = 1,
FUN = function(x) m[x[1], x[2]]
) |>
min()
apply(
X = neighbors,
MARGIN = 1,
FUN = function(x) m[x[1], x[2]]
) |>
sort()
#neighbors data frame
neighbors <- data.frame(
x = c(x, x_move),
y = c(y_move, y),
row.names = c("up", "left")
)
neighbors$cost <- apply(
X = neighbors,
MARGIN = 1,
FUN = function(x) m[x[1], x[2]]
)
neighbors
y_move <- max(y - 1, 1)
x_move <- max(x - 1, 1)
neighbors <- data.frame(
x = c(x, x_move),
y = c(y_move, y),
row.names = c("up", "left")
)
neighbors$cost <- apply(
X = neighbors,
MARGIN = 1,
FUN = function(x) m[x[1], x[2]]
)
neighbors
neighbors
neighbors[which.min(neighbors$cost), c("x", "y")]
as.vector(neighbors[which.min(neighbors$cost), c("x", "y")])
m
m[1:5, 1:5]
y_move <- max(y - 1, 1)
x_move <- max(x - 1, 1)
moves <- list(
left = c(x_move, y),
up = c(x, y_move)
)
sapply(
X = moves,
FUN = function(move) m[move["x"], move["y"]]
)
y_move <- max(y - 1, 1)
x_move <- max(x - 1, 1)
moves <- list(
left = c(x_move, y),
up = c(x, y_move)
)
moves
y_step <- max(y - 1, 1)
x_step <- max(x - 1, 1)
steps <- list(
left = c(x_step, y),
up = c(x, y_step)
)
costs <- sapply(
X = steps,
FUN = function(step) m[step[1], step[2]]
)
costs
steps[[which.min(costs)]]
dim(m_cost)
sum(dim(m_cost))
rows <- sum(dim(m_cost))
path <- data.frame(
x = rep(NA, rows),
y = NA,
distance = NA
)
rows <- sum(dim(m_cost))
path <- data.frame(
x = rep(NA, rows),
y = NA,
distance = NA
)
head(path)
path <- data.frame(
x = ncol(m_cost),
y = nrow(m_cost)
)
path$distance <- m_dist[path$x, path$y]
path
path <- data.frame(
x = ncol(m_cost),
y = nrow(m_cost)
)
path$distance <- m_dist[path$x, path$y]
path
step <- tail(x = path, n = 1)
next_step <- function(m, step){
x <- step$x
y <- step$y
steps <- list(
left = c(max(x - 1, 1), y),
up = c(x, max(y - 1, 1))
)
costs <- sapply(
X = steps,
FUN = function(step) m[step[1], step[2]]
)
steps[[which.min(costs)]]
}
next_step
next_step <- function(m, step){
x <- step$x
y <- step$y
steps <- list(
left = c(max(x - 1, 1), y),
up = c(x, max(y - 1, 1))
)
costs <- sapply(
X = steps,
FUN = function(step) m[step[1], step[2]]
)
steps[[which.min(costs)]]
}
next_step(m = m_cost, step = tail(path, n = 1))
m_cst[12:13, 12:13]
m_cost[12:13, 12:13]
step <- tail(path, n = 1)
m <- m_cost
x <- step$x
y <- step$y
x
y
steps <- list(
left = c(max(x - 1, 1), y),
up = c(x, max(y - 1, 1))
)
steps
costs <- sapply(
X = steps,
FUN = function(step) m[step[1], step[2]]
)
costs
c(max(x - 1, 1), y)
x <- step$x
y <- step$y
steps <- list(
left = c(max(x - 1, 1), y),
up = c(x, max(y - 1, 1))
)
steps
x <- step$x
y <- step$y
steps <- list(
left = c(max(x - 1, 1), y),
up = c(x, max(y - 1, 1))
)
costs <- sapply(
X = steps,
FUN = function(step) m[step[2], step[1]]
)
costs
steps[[which.min(costs)]]
